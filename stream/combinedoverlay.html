<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combined Race Overlay - OBS</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* Setup screen */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 1000;
        }

        .setup-screen.hidden {
            display: none;
        }

        .setup-screen h1 {
            font-family: 'Orbitron', sans-serif;
            color: #00d4ff;
            font-size: 28px;
        }

        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: #252540;
            padding: 30px;
            border-radius: 12px;
            min-width: 400px;
        }

        .setup-form label {
            color: #aaa;
            font-size: 12px;
            text-transform: uppercase;
        }

        .setup-form input {
            padding: 12px 16px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 16px;
            font-family: 'Roboto Mono', monospace;
        }

        .setup-form button {
            padding: 14px 24px;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 6px;
            color: #000;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
        }

        .url-hint {
            padding: 15px;
            background: #333;
            border-radius: 8px;
            color: #888;
            font-size: 12px;
            font-family: monospace;
        }

        .url-hint code {
            color: #00d4ff;
        }

        /* ==================== FLAG OVERLAY - TOP LEFT ==================== */
        .flag-container {
            position: fixed;
            top: 15px;
            left: 15px;
        }

        .flag-overlay {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: linear-gradient(180deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 25, 0.95) 100%);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .flag-indicator {
            width: 45px;
            height: 45px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
        }

        .flag-indicator.green { background: linear-gradient(135deg, #00ff88, #00cc66); animation: flagPulse 2s infinite; }
        .flag-indicator.yellow { background: linear-gradient(135deg, #ffdd00, #ffaa00); animation: flagPulse 0.5s infinite; }
        .flag-indicator.red { background: linear-gradient(135deg, #ff4444, #cc0000); animation: flagPulse 0.3s infinite; }
        .flag-indicator.checkered { background: repeating-conic-gradient(#000 0deg 90deg, #fff 90deg 180deg); background-size: 20px 20px; }
        .flag-indicator.sc { background: linear-gradient(135deg, #ffaa00, #ff8800); animation: flagPulse 1s infinite; }
        .flag-indicator.fcy { background: linear-gradient(135deg, #ffdd00, #ffaa00); animation: flagPulse 1s infinite; }
        .flag-indicator.code60 { background: linear-gradient(135deg, #ffdd00, #ff8800); animation: flagPulse 1s infinite; font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 900; color: #000; }
        .flag-indicator.not-started { background: linear-gradient(135deg, #666, #444); }

        @keyframes flagPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.03); }
        }

        .flag-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .race-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .flag-status {
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flag-status.green { color: #00ff88; }
        .flag-status.yellow { color: #ffdd00; }
        .flag-status.red { color: #ff4444; }
        .flag-status.checkered { color: #fff; }
        .flag-status.sc { color: #ffaa00; }
        .flag-status.fcy { color: #ffdd00; }
        .flag-status.code60 { color: #ff8800; }
        .flag-status.not-started { color: #888; }

        /* ==================== RACE TIME - TOP CENTER ==================== */
        .timer-container {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .timer-overlay {
            padding: 12px 25px;
            background: linear-gradient(180deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 25, 0.95) 100%);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .timer-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .race-timer {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #00d4ff;
        }

        /* ==================== MESSAGES - TOP RIGHT ==================== */
        .messages-container {
            position: fixed;
            top: 15px;
            right: 15px;
            max-width: 400px;
        }

        .messages-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .message-item {
            padding: 10px 14px;
            background: linear-gradient(180deg, rgba(30, 30, 60, 0.95) 0%, rgba(20, 20, 45, 0.95) 100%);
            border-radius: 6px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
            border-left: 4px solid #00d4ff;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            line-height: 1.3;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message-item.penalty { border-left-color: #ff4444; background: linear-gradient(180deg, rgba(80, 20, 20, 0.95) 0%, rgba(50, 15, 15, 0.95) 100%); }
        .message-item.yellow { border-left-color: #ffdd00; background: linear-gradient(180deg, rgba(80, 70, 20, 0.95) 0%, rgba(50, 45, 15, 0.95) 100%); }
        .message-item.safety { border-left-color: #ff8800; background: linear-gradient(180deg, rgba(80, 50, 20, 0.95) 0%, rgba(50, 30, 15, 0.95) 100%); }
        .message-item.green { border-left-color: #00ff88; background: linear-gradient(180deg, rgba(20, 60, 40, 0.95) 0%, rgba(15, 40, 30, 0.95) 100%); }

        /* ==================== CAR OVERLAY - BOTTOM CENTER ==================== */
        .car-container {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .car-overlay {
            display: flex;
            align-items: stretch;
            background: linear-gradient(180deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 25, 0.95) 100%);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .position-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 65px;
            padding: 10px 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 900;
            color: #fff;
            background: linear-gradient(135deg, #00d4ff, #0088aa);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .position-badge.p1 { background: linear-gradient(135deg, #ffd700, #cc9900); color: #000; }
        .position-badge.p2 { background: linear-gradient(135deg, #c0c0c0, #888888); color: #000; }
        .position-badge.p3 { background: linear-gradient(135deg, #cd7f32, #8b4513); color: #fff; }

        .car-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 10px 18px;
            min-width: 180px;
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .car-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: bold;
            color: #00d4ff;
        }

        .driver-name {
            font-size: 13px;
            color: #ccc;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 160px;
        }

        .timing-section {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            gap: 15px;
        }

        .timing-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 55px;
        }

        .timing-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .timing-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 15px;
            font-weight: bold;
            color: #fff;
        }

        .timing-value.gap { color: #ffd700; }
        .timing-value.gap-ahead { color: #ff6b6b; }
        .timing-value.gap-behind { color: #4ecdc4; }

        .sectors-container {
            display: flex;
            gap: 6px;
            padding: 10px 12px;
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .sector {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 60px;
            padding: 6px 10px;
            border-radius: 5px;
            background: rgba(255,255,255,0.05);
        }

        .sector.active {
            background: rgba(0, 212, 255, 0.2);
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
        }

        .sector-label {
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .sector.s1 .sector-label { color: #ff6b6b; }
        .sector.s2 .sector-label { color: #4ecdc4; }
        .sector.s3 .sector-label { color: #a78bfa; }

        .sector-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .lap-section {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            gap: 15px;
            border-left: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
        }

        .lap-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
        }

        .current-lap-time {
            font-family: 'Roboto Mono', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #00d4ff;
        }

        .track-progress {
            position: relative;
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.1);
            margin-top: 4px;
            border-radius: 3px;
            overflow: hidden;
        }

        .track-progress-marker {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 9px;
            background: #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            box-shadow: 0 0 6px rgba(255,255,255,0.8);
            transition: left 0.5s ease;
        }

        /* Connection indicator */
        .connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
            font-size: 10px;
            color: #888;
        }

        .connection-status.connected { color: #00ff88; }
        .connection-status.disconnected { color: #ff4444; }

        body.obs-mode .connection-status { display: none; }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div class="setup-screen" id="setupScreen">
        <h1>üèÅ Combined Race Overlay</h1>
        
        <div class="setup-form">
            <label>Car Number to Track</label>
            <input type="text" id="carNumberInput" placeholder="e.g., 36" autofocus>
            
            <label>WebSocket URL</label>
            <input type="text" id="wsUrlInput" placeholder="wss://..." value="wss://livetiming.getraceresults.com/lt/connect?transport=webSockets&amp;clientProtocol=1.5&amp;_tk=84992738a8304d15a8f20722b7a27947&amp;_gr=w&amp;_tkdm=1041140&amp;connectionToken=FWT09RJEOFAHDbxfUngcCCb1h6UM6Yy0rx%2BBv0jXaVEC5KnepwdkWeHqZh58rBQmrV1hEAOpLQbfzrSUbMLBjHrrRU0NjN1kSovhFcPmOY%2BQxqWcOvb4ua56RpUtVb1O&amp;tid=6">
            
            <label>Max Messages</label>
            <input type="number" id="maxMessagesInput" value="3" min="1" max="10" style="width: 80px;">
            
            <button onclick="startOverlay()">Start Overlay</button>
        </div>
        
        <div class="url-hint">
            <code>?car=36&ws=wss://...&msgs=3</code>
        </div>
    </div>

    <!-- FLAG - Top Left -->
    <div class="flag-container" id="flagContainer" style="display: none;">
        <div class="flag-overlay">
            <div class="flag-indicator not-started" id="flagIndicator">üèÅ</div>
            <div class="flag-info">
                <div class="race-name" id="raceName">Waiting...</div>
                <div class="flag-status not-started" id="flagStatus">NOT STARTED</div>
            </div>
        </div>
    </div>

    <!-- TIMER - Top Center -->
    <div class="timer-container" id="timerContainer" style="display: none;">
        <div class="timer-overlay">
            <div class="timer-label" id="timerLabel">Time Remaining</div>
            <div class="race-timer" id="raceTimer">--:--:--</div>
        </div>
    </div>

    <!-- MESSAGES - Top Right -->
    <div class="messages-container" id="messagesContainer" style="display: none;">
        <div class="messages-list" id="messagesList"></div>
    </div>

    <!-- CAR - Bottom Center -->
    <div class="car-container" id="carContainer" style="display: none;">
        <div class="car-overlay" id="carOverlay">
            <div class="position-badge" id="positionBadge">-</div>
            <div class="car-info">
                <div class="car-number" id="carNumber">#--</div>
                <div class="driver-name" id="driverName">Loading...</div>
            </div>
            <div class="timing-section">
                <div class="timing-block">
                    <div class="timing-label">Gap</div>
                    <div class="timing-value gap" id="gapToLeader">--</div>
                </div>
                <div class="timing-block">
                    <div class="timing-label">‚Üë Ahead</div>
                    <div class="timing-value gap-ahead" id="gapAhead">--</div>
                </div>
                <div class="timing-block">
                    <div class="timing-label">‚Üì Behind</div>
                    <div class="timing-value gap-behind" id="gapBehind">--</div>
                </div>
                <div class="timing-block">
                    <div class="timing-label">Lap</div>
                    <div class="timing-value" id="lapCount">--</div>
                </div>
            </div>
            <div class="sectors-container">
                <div class="sector s1" id="sector1">
                    <div class="sector-label">S1</div>
                    <div class="sector-time" id="s1Time">--</div>
                </div>
                <div class="sector s2" id="sector2">
                    <div class="sector-label">S2</div>
                    <div class="sector-time" id="s2Time">--</div>
                </div>
                <div class="sector s3" id="sector3">
                    <div class="sector-label">S3</div>
                    <div class="sector-time" id="s3Time">--</div>
                </div>
            </div>
            <div class="lap-section">
                <div class="timing-block">
                    <div class="timing-label">Current Lap</div>
                    <div class="current-lap-time" id="currentLapTime">0:00.000</div>
                </div>
                <div class="timing-block">
                    <div class="timing-label">Last Lap</div>
                    <div class="lap-time" id="lastLapTime">--</div>
                </div>
            </div>
        </div>
        <div class="track-progress">
            <div class="track-progress-marker" id="progressMarker" style="left: 0%;"></div>
        </div>
    </div>

    <div class="connection-status" id="connectionStatus">Disconnected</div>

    <script>
        // Configuration
        let config = {
            carNumber: null,
            wsUrl: null,
            maxMessages: 3
        };

        // State
        let ws = null;
        let headers = [];
        let rows = [];
        let messages = [];
        let carData = null;
        let raceStartTime = null;
        let raceEndTime = null;
        let raceDuration = null;
        let raceElapsed = null;
        let lastElapsedUpdateTime = null; // When we last received elapsed time
        let animationState = {
            lapStartTime: Date.now(),
            sectorTimes: [35, 35, 30],
            lastLapNum: 0,
            lastLapTime: null
        };

        function intToRgb(colorInt) {
            if (!colorInt && colorInt !== 0) return null;
            const r = (colorInt >> 16) & 255;
            const g = (colorInt >> 8) & 255;
            const b = colorInt & 255;
            return `${r},${g},${b}`;
        }

        // Parse URL params
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.has('car')) {
                config.carNumber = params.get('car');
                document.getElementById('carNumberInput').value = config.carNumber;
            }
            if (params.has('ws')) {
                config.wsUrl = params.get('ws');
                document.getElementById('wsUrlInput').value = config.wsUrl;
            }
            if (params.has('msgs')) {
                config.maxMessages = parseInt(params.get('msgs')) || 3;
                document.getElementById('maxMessagesInput').value = config.maxMessages;
            }
            
            if (config.carNumber && config.wsUrl) {
                document.body.classList.add('obs-mode');
                startOverlay();
            }
        }

        function startOverlay() {
            config.carNumber = document.getElementById('carNumberInput').value.trim();
            config.wsUrl = document.getElementById('wsUrlInput').value.trim();
            config.maxMessages = parseInt(document.getElementById('maxMessagesInput').value) || 3;
            
            if (!config.carNumber) {
                alert('Please enter a car number');
                return;
            }
            if (!config.wsUrl) {
                alert('Please enter a WebSocket URL');
                return;
            }
            
            // Hide setup, show overlays
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('flagContainer').style.display = 'block';
            document.getElementById('timerContainer').style.display = 'block';
            document.getElementById('messagesContainer').style.display = 'block';
            document.getElementById('carContainer').style.display = 'block';
            
            document.getElementById('carNumber').textContent = '#' + config.carNumber;
            
            connect(config.wsUrl);
            setInterval(updateTimer, 1000);
            requestAnimationFrame(animationLoop);
        }

        function connect(url) {
            document.getElementById('connectionStatus').textContent = 'Connecting...';
            
            ws = new WebSocket(url);
            
            ws.onopen = () => {
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'connection-status connected';
            };
            
            ws.onmessage = (event) => {
                if (!event.data || event.data === '{}') return;
                try {
                    const message = JSON.parse(event.data);
                    if (message.M) message.M.forEach(m => processMessage(m));
                } catch (e) {}
            };
            
            ws.onclose = () => {
                document.getElementById('connectionStatus').textContent = 'Disconnected';
                document.getElementById('connectionStatus').className = 'connection-status disconnected';
                setTimeout(() => { if (config.wsUrl) connect(config.wsUrl); }, 3000);
            };
        }

        function processMessage(msg) {
            let method, args;
            if (Array.isArray(msg)) { method = msg[0]; args = msg.slice(1); }
            else if (msg.M) { method = msg.M; args = msg.A || []; }
            else return;
            
            switch (method) {
                case '_':
                    if (args[0] && typeof args[0] === 'string') {
                        try {
                            let decompressed = LZString.decompressFromUTF16(args[0]);
                            if (!decompressed) decompressed = LZString.decompress(args[0]);
                            if (decompressed) {
                                const data = JSON.parse(decompressed);
                                if (Array.isArray(data)) {
                                    data.forEach(m => {
                                        if (Array.isArray(m)) {
                                            if (m[0] === 'h_i') updateHeatState(m[1]);
                                            if (m[0] === 'r_i') processResultsInit(m[1]);
                                            if (m[0] === 'm_i') processMessagesInit(m[1]);
                                        }
                                    });
                                }
                            }
                        } catch (e) { console.error('Decompress error:', e); }
                    }
                    break;
                case 'h_i':
                case 'h_h':
                    updateHeatState(args[0]);
                    break;
                case 'r_i':
                    processResultsInit(args[0]);
                    break;
                case 'r_c':
                    processResultsCells(args);
                    break;
                case 'm_i':
                    processMessagesInit(args[0]);
                    break;
                case 'm_c':
                    addMessage(args[0]);
                    break;
            }
        }

        // ==================== HEAT STATE ====================
        function updateHeatState(data) {
            if (!data) return;
            
            console.log('[Heat] Data:', data);
            
            if (data.n) {
                document.getElementById('raceName').textContent = data.n;
            }
            
            if (data.f !== undefined) {
                const flagMap = {
                    '-1': { cls: 'not-started', text: 'NOT STARTED', icon: 'üèÅ' },
                    '0': { cls: 'not-started', text: 'NOT STARTED', icon: 'üèÅ' },
                    '1': { cls: 'not-started', text: 'READY', icon: 'üèÅ' },
                    '2': { cls: 'red', text: 'RED FLAG', icon: 'üî¥' },
                    '3': { cls: 'yellow', text: 'YELLOW', icon: 'üü°' },
                    '4': { cls: 'fcy', text: 'FCY', icon: 'üü°' },
                    '5': { cls: 'checkered', text: 'FINISHED', icon: 'üèÅ' },
                    '6': { cls: 'green', text: 'GREEN', icon: 'üü¢' },
                    '7': { cls: 'sc', text: 'SAFETY CAR', icon: 'üöó' },
                    '8': { cls: 'code60', text: 'CODE 60', icon: '60' }
                };
                
                const flagInfo = flagMap[String(data.f)] || flagMap['0'];
                document.getElementById('flagIndicator').className = 'flag-indicator ' + flagInfo.cls;
                document.getElementById('flagIndicator').textContent = flagInfo.icon;
                document.getElementById('flagStatus').className = 'flag-status ' + flagInfo.cls;
                document.getElementById('flagStatus').textContent = flagInfo.text;
            }
            
            // s = start time, e = end time, lt = duration, r = elapsed
            if (data.s !== undefined) { raceStartTime = data.s; console.log('[Heat] Start time:', data.s); }
            if (data.e !== undefined) { raceEndTime = data.e; console.log('[Heat] End time:', data.e); }
            if (data.lt !== undefined) { raceDuration = data.lt; console.log('[Heat] Duration:', data.lt); }
            if (data.r !== undefined && data.r > 0) { 
                raceElapsed = data.r; 
                lastElapsedUpdateTime = Date.now();
                console.log('[Heat] Elapsed:', data.r); 
            }
            
            // st is sometimes used for start time in milliseconds
            if (data.st !== undefined) { raceStartTime = data.st; console.log('[Heat] Start time (st):', data.st); }
        }

        function updateTimer() {
            const timerEl = document.getElementById('raceTimer');
            const labelEl = document.getElementById('timerLabel');
            
            // Interpolate elapsed time locally
            let currentElapsed = raceElapsed;
            if (raceElapsed && lastElapsedUpdateTime) {
                const timeSinceUpdate = (Date.now() - lastElapsedUpdateTime) * 1000; // to microseconds
                currentElapsed = raceElapsed + timeSinceUpdate;
            }
            
            // Calculate time remaining
            let remaining = null;
            
            if (raceDuration && currentElapsed) {
                // We have duration and elapsed - calculate remaining
                remaining = raceDuration - currentElapsed;
            }
            
            if (remaining !== null && remaining > 0) {
                // Show time remaining
                labelEl.textContent = 'Time Remaining';
                const totalSec = Math.floor(remaining / 1000000);
                const hours = Math.floor(totalSec / 3600);
                const mins = Math.floor((totalSec % 3600) / 60);
                const secs = totalSec % 60;
                
                timerEl.textContent = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                timerEl.style.color = remaining < 600000000 ? '#ff6b6b' : '#00d4ff'; // Red when < 10 min
            } else if (currentElapsed && currentElapsed > 1000000) {
                // Show elapsed time
                labelEl.textContent = 'Race Time';
                const totalSec = Math.floor(currentElapsed / 1000000);
                const hours = Math.floor(totalSec / 3600);
                const mins = Math.floor((totalSec % 3600) / 60);
                const secs = totalSec % 60;
                
                timerEl.textContent = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                timerEl.style.color = '#00d4ff';
            } else {
                labelEl.textContent = 'Race Time';
                timerEl.textContent = '--:--:--';
                timerEl.style.color = '#00d4ff';
            }
        }

        // ==================== RESULTS ====================
        function processResultsInit(data) {
            if (!data) return;
            
            rows = [];
            
            if (data.l?.h) {
                headers = data.l.h.map(h => {
                    let key = h.n ? h.n.toLowerCase().replace(/\s/g, '_') : '';
                    if (h.p) key += '_' + h.p;
                    return { name: h.n || '', key: key };
                });
            }
            
            if (data.r && Array.isArray(data.r)) {
                data.r.forEach(cell => {
                    if (!Array.isArray(cell) || cell.length < 3) return;
                    const [rowIdx, colIdx, value] = cell;
                    if (rowIdx === -1 && colIdx === -1) return;
                    
                    while (rows.length <= rowIdx) rows.push({ _index: rows.length });
                    rows[rowIdx]['col_' + colIdx] = value;
                    
                    const header = headers[colIdx];
                    if (header && header.key) rows[rowIdx][header.key] = value;
                });
            }
            
            updateCarDisplay();
        }

        function processResultsCells(args) {
            if (!args || !Array.isArray(args)) return;
            
            args.forEach(cellArray => {
                if (!Array.isArray(cellArray)) return;
                
                cellArray.forEach(cell => {
                    if (!Array.isArray(cell) || cell.length < 3) return;
                    const [rowIdx, colIdx, value] = cell;
                    if (rowIdx === -1 && colIdx === -1) return;
                    
                    while (rows.length <= rowIdx) rows.push({ _index: rows.length });
                    rows[rowIdx]['col_' + colIdx] = value;
                    
                    const header = headers[colIdx];
                    if (header && header.key) rows[rowIdx][header.key] = value;
                });
            });
            
            updateCarDisplay();
        }

        function updateCarDisplay() {
            carData = rows.find(r => {
                const num1 = String(r.startnumber || '').trim();
                const num2 = String(r.col_2 || '').trim();
                const target = String(config.carNumber).trim();
                return num1 === target || num2 === target;
            });
            
            if (!carData) {
                document.getElementById('driverName').textContent = 'Car not found';
                return;
            }
            
            // Position
            const pos = parseInt(carData.position || carData.col_0 || '0');
            const posEl = document.getElementById('positionBadge');
            posEl.textContent = pos || '-';
            posEl.className = 'position-badge';
            if (pos === 1) posEl.classList.add('p1');
            else if (pos === 2) posEl.classList.add('p2');
            else if (pos === 3) posEl.classList.add('p3');
            
            // Driver
            document.getElementById('driverName').textContent = carData.name || carData.currentdriver || carData.col_4 || 'Unknown';
            
            // Gap to leader (our car's diff)
            const ourDiff = carData.diff || carData.col_11 || carData.col_12;
            document.getElementById('gapToLeader').textContent = (pos === 1) ? 'LEADER' : (ourDiff || '--');
            
            // Find car ahead (position - 1) and behind (position + 1) using diff
            let gapAhead = '--';
            let gapBehind = '--';
            
            if (pos > 0) {
                if (pos === 1) {
                    gapAhead = '--';
                } else {
                    // Find car ahead and calculate interval from diff values
                    const carAhead = rows.find(r => {
                        const p = parseInt(r.position || r.col_0 || '0');
                        return p === pos - 1;
                    });
                    if (carAhead) {
                        const aheadDiff = carAhead.diff || carAhead.col_11 || carAhead.col_12;
                        // Interval = our diff - their diff (if both are times)
                        const ourDiffNum = parseFloat(String(ourDiff).replace(/[^0-9.-]/g, ''));
                        const aheadDiffNum = parseFloat(String(aheadDiff).replace(/[^0-9.-]/g, ''));
                        
                        if (!isNaN(ourDiffNum) && !isNaN(aheadDiffNum)) {
                            const interval = ourDiffNum - aheadDiffNum;
                            gapAhead = interval.toFixed(3);
                        } else if (ourDiff) {
                            // Just use our diff as the gap
                            gapAhead = ourDiff;
                        }
                    }
                }
                
                // Find car behind
                const carBehind = rows.find(r => {
                    const p = parseInt(r.position || r.col_0 || '0');
                    return p === pos + 1;
                });
                if (carBehind) {
                    const behindDiff = carBehind.diff || carBehind.col_11 || carBehind.col_12;
                    const ourDiffNum = parseFloat(String(ourDiff).replace(/[^0-9.-]/g, ''));
                    const behindDiffNum = parseFloat(String(behindDiff).replace(/[^0-9.-]/g, ''));
                    
                    if (!isNaN(ourDiffNum) && !isNaN(behindDiffNum)) {
                        const interval = behindDiffNum - ourDiffNum;
                        gapBehind = '+' + interval.toFixed(3);
                    } else if (behindDiff) {
                        gapBehind = '+' + String(behindDiff).replace(/^[+-]/, '');
                    }
                }
            }
            
            document.getElementById('gapAhead').textContent = gapAhead;
            document.getElementById('gapBehind').textContent = gapBehind;
            document.getElementById('lapCount').textContent = carData.laps || carData.col_10 || '--';
            
            // Sectors
            const s1Raw = carData.sectortimes_1 || carData.col_16;
            const s2Raw = carData.sectortimes_2 || carData.col_17;
            const s3Raw = carData.sectortimes_3 || carData.col_18;
            
            const isValidSector = (v) => v > 5000000 && v < 300000000;
            const s1 = parseFloat(s1Raw);
            const s2 = parseFloat(s2Raw);
            const s3 = parseFloat(s3Raw);
            
            document.getElementById('s1Time').textContent = isValidSector(s1) ? (s1 / 1000000).toFixed(3) : '--';
            document.getElementById('s2Time').textContent = isValidSector(s2) ? (s2 / 1000000).toFixed(3) : '--';
            document.getElementById('s3Time').textContent = isValidSector(s3) ? (s3 / 1000000).toFixed(3) : '--';
            
            if (isValidSector(s1)) animationState.sectorTimes[0] = s1 / 1000000;
            if (isValidSector(s2)) animationState.sectorTimes[1] = s2 / 1000000;
            if (isValidSector(s3)) animationState.sectorTimes[2] = s3 / 1000000;
            
            // Lap time
            const lastLap = carData.lastroundtime || carData.col_13;
            const lastLapNum = parseInt(lastLap);
            if (lastLapNum > 30000000 && lastLapNum < 600000000) {
                const totalSec = lastLapNum / 1000000;
                const mins = Math.floor(totalSec / 60);
                const secs = (totalSec % 60).toFixed(3);
                document.getElementById('lastLapTime').textContent = mins > 0 ? `${mins}:${secs.padStart(6, '0')}` : secs;
                
                // Reset lap timer if last lap time changed
                if (lastLapNum !== animationState.lastLapTime) {
                    animationState.lastLapTime = lastLapNum;
                    animationState.lapStartTime = Date.now();
                }
            }
            
            // Also reset on lap count change as backup
            const currentLap = parseInt(carData.laps || carData.col_10 || '0');
            if (currentLap > animationState.lastLapNum && currentLap > 0) {
                animationState.lastLapNum = currentLap;
                // Only reset if not already reset by lap time change
                if (!animationState.lastLapTime) {
                    animationState.lapStartTime = Date.now();
                }
            }
        }

        function animationLoop() {
            if (animationState.lapStartTime) {
                const elapsed = (Date.now() - animationState.lapStartTime) / 1000;
                const [s1, s2, s3] = animationState.sectorTimes;
                const totalLap = s1 + s2 + s3;
                
                let position, currentSector;
                
                if (elapsed < s1) {
                    currentSector = 1;
                    position = (elapsed / s1) * 33.3;
                } else if (elapsed < s1 + s2) {
                    currentSector = 2;
                    position = 33.3 + ((elapsed - s1) / s2) * 33.3;
                } else if (elapsed < totalLap) {
                    currentSector = 3;
                    position = 66.6 + ((elapsed - s1 - s2) / s3) * 33.3;
                } else {
                    currentSector = 3;
                    position = 98;
                }
                
                document.getElementById('progressMarker').style.left = position + '%';
                document.getElementById('sector1').classList.toggle('active', currentSector === 1);
                document.getElementById('sector2').classList.toggle('active', currentSector === 2);
                document.getElementById('sector3').classList.toggle('active', currentSector === 3);
                
                // Update current lap timer
                const mins = Math.floor(elapsed / 60);
                const secs = Math.floor(elapsed % 60);
                const millis = Math.floor((elapsed % 1) * 1000);
                document.getElementById('currentLapTime').textContent = 
                    `${mins}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
            }
            
            requestAnimationFrame(animationLoop);
        }

        // ==================== MESSAGES ====================
        function processMessagesInit(data) {
            messages = [];
            if (Array.isArray(data)) {
                data.forEach(m => {
                    messages.push({ text: m.t, bc: intToRgb(m.bc) });
                });
            }
            renderMessages();
        }

        function addMessage(data) {
            if (!data) return;
            messages.push({ text: data.t, bc: intToRgb(data.bc) });
            while (messages.length > config.maxMessages * 2) messages.shift();
            renderMessages();
        }

        function getMessageType(text) {
            const t = (text || '').toUpperCase();
            if (t.includes('PENALTY') || t.includes('BLACK AND WHITE') || t.includes('DRIVE THROUGH')) return 'penalty';
            if (t.includes('YELLOW') || t.includes('CAUTION')) return 'yellow';
            if (t.includes('SAFETY CAR') || t.includes('FCY') || t.includes('CODE 60')) return 'safety';
            if (t.includes('GREEN FLAG') || t.includes('RACE START')) return 'green';
            return 'info';
        }

        function renderMessages() {
            const list = document.getElementById('messagesList');
            if (messages.length === 0) {
                list.innerHTML = '';
                return;
            }
            
            const recent = messages.slice(-config.maxMessages).reverse();
            list.innerHTML = recent.map(m => {
                const type = getMessageType(m.text);
                return `<div class="message-item ${type}">${m.text || ''}</div>`;
            }).join('');
        }

        // Initialize
        parseUrlParams();
    </script>
</body>
</html>
