<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Timing - getraceresults.com</title>
    <!-- LZString for decompressing bulk messages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Orbitron:wght@400;500;600;700;800&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Background colors - darker for better contrast */
            --bg-primary: #08080d;
            --bg-secondary: #101018;
            --bg-tertiary: #181824;
            --bg-row-odd: #0c0c14;
            --bg-row-even: #101018;
            --bg-row-hover: #1a1a2e;
            
            /* Text colors - high contrast */
            --text-primary: #f5f5fa;
            --text-secondary: #c0c0d0;
            --text-muted: #808098;
            --text-bright: #ffffff;
            --text-data: #e8e8f0;
            
            /* Accent colors - vibrant but not harsh */
            --accent-red: #ff3344;
            --accent-green: #00ff88;
            --accent-yellow: #ffe033;
            --accent-purple: #c060ff;
            --accent-cyan: #00e5ff;
            --accent-orange: #ff9922;
            --accent-blue: #4499ff;
            
            /* Timing specific colors */
            --color-best-overall: #cc44ff;
            --color-best-personal: #00dd66;
            --color-gap: #ffcc00;
            --color-interval: #ff9944;
            
            /* Border */
            --border-color: #2a2a44;
            --border-subtle: rgba(255, 255, 255, 0.05);
            --border-highlight: rgba(0, 229, 255, 0.3);
            
            /* Sizing - larger for readability */
            --header-height: 80px;
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-md: 15px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-timing: 15px;
            --row-height: 44px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Rajdhani', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: var(--font-size-md);
            font-weight: 500;
            line-height: 1.5;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            letter-spacing: 0.2px;
        }

        /* Subtle grid background */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                linear-gradient(90deg, transparent 49.5%, rgba(255,255,255,0.015) 49.5%, rgba(255,255,255,0.015) 50.5%, transparent 50.5%),
                linear-gradient(0deg, transparent 49.5%, rgba(255,255,255,0.015) 49.5%, rgba(255,255,255,0.015) 50.5%, transparent 50.5%);
            background-size: 60px 60px;
            pointer-events: none;
            z-index: 0;
        }

        /* Connection Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        
        .modal.hidden { display: none; }
        
        .modal-content {
            background: var(--bg-secondary);
            padding: var(--spacing-lg);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            max-width: 800px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        
        .modal h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-red);
            margin-bottom: var(--spacing-md);
        }
        
        .modal p {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-md);
            line-height: 1.7;
            font-size: var(--font-size-large);
        }
        
        .modal input {
            width: 100%;
            padding: 14px 16px;
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 8px;
            margin-bottom: var(--spacing-md);
            transition: border-color 0.2s;
        }
        
        .modal input:focus {
            outline: none;
            border-color: var(--accent-green);
        }
        
        .modal button {
            padding: 14px 36px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: var(--accent-green);
            color: #000;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        
        .modal button:hover {
            background: #00e07a;
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }
        
        .modal .instructions {
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 8px;
            margin-bottom: var(--spacing-md);
            font-size: var(--font-size-base);
            border-left: 3px solid var(--accent-cyan);
        }
        
        .modal .instructions ol {
            margin-left: 1.5rem;
            margin-top: var(--spacing-sm);
        }
        
        .modal .instructions li {
            margin-bottom: var(--spacing-sm);
            line-height: 1.6;
        }

        /* Header */
        .header {
            background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            border-bottom: 2px solid var(--border-color);
            padding: var(--spacing-md) var(--spacing-lg);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            min-height: var(--header-height);
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.6rem;
            font-weight: 800;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--accent-red) 0%, var(--accent-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .race-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
            flex-wrap: wrap;
        }

        /* Flag Indicator - Improved readability */
        .flag-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            min-width: 140px;
            justify-content: center;
        }

        .flag-indicator.green { 
            background: linear-gradient(135deg, #00aa44 0%, #00dd66 100%); 
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            animation: flagPulse 2s infinite; 
        }
        .flag-indicator.red { 
            background: linear-gradient(135deg, #cc0000 0%, #ff2222 100%); 
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            animation: flagPulse 1s infinite; 
        }
        .flag-indicator.yellow { 
            background: linear-gradient(135deg, #ccaa00 0%, #ffdd00 100%); 
            color: #1a1a00;
            font-weight: 800;
            animation: flagPulse 1s infinite; 
        }
        .flag-indicator.checkered { 
            background: repeating-conic-gradient(#000 0deg 90deg, #fff 90deg 180deg) 0 0/16px 16px; 
            color: #000; 
            text-shadow: 0 0 3px #fff;
        }
        .flag-indicator.not-started { 
            background: var(--bg-tertiary); 
            border: 2px solid var(--border-color);
            color: var(--text-muted);
        }
        .flag-indicator.code60 {
            background: linear-gradient(135deg, #ffdd00, #ff8800);
            color: #000;
            font-weight: 900;
            animation: flagPulse 1s infinite;
        }

        @keyframes flagPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.15); }
            50% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.3); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }
        
        @keyframes carMove {
            0% { transform: translate(-50%, -50%); }
            100% { transform: translate(-50%, -50%); }
        }

        /* Clock and Lap displays */
        .clock-display { text-align: center; }
        .clock-label { 
            font-size: var(--font-size-xs); 
            color: var(--text-muted); 
            text-transform: uppercase; 
            letter-spacing: 2px;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .clock-time { 
            font-family: 'Roboto Mono', monospace; 
            font-size: 2.4rem; 
            font-weight: 700;
            color: var(--text-bright);
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .lap-counter { text-align: center; }
        .lap-label { 
            font-size: var(--font-size-xs); 
            color: var(--text-muted); 
            text-transform: uppercase; 
            letter-spacing: 2px;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .lap-value { 
            font-family: 'Orbitron', sans-serif; 
            font-size: 2rem; 
            font-weight: 700;
            color: var(--text-bright);
            letter-spacing: 1px;
        }
        
        /* Time to go / ETA displays */
        .time-to-go-display, .eta-display {
            text-align: center;
        }
        .time-to-go-label, .eta-label {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .time-to-go-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.6rem;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .eta-value {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--accent-cyan);
        }

        /* Connection Status */
        .connection-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 13px;
            font-weight: 500;
            padding: 10px 16px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }
        
        .connection-status:hover {
            background: var(--bg-row-hover);
            border-color: var(--text-muted);
        }

        .connection-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: blink 1s infinite;
        }

        .connection-dot.connected {
            background: var(--accent-green);
            animation: none;
            box-shadow: 0 0 8px var(--accent-green);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Main Layout */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 340px;
            grid-template-rows: 1fr auto;
            grid-template-areas: 
                "results sidebar"
                "graph graph";
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            position: relative;
            z-index: 1;
        }

        .results-section {
            grid-area: results;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .sidebar {
            grid-area: sidebar;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
        }

        .position-graph-section {
            grid-area: graph;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            padding: var(--spacing-md);
        }

        .position-graph-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        @media (max-width: 1100px) {
            .main-content { 
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "results"
                    "sidebar"
                    "graph";
            }
        }

        /* Section Headers */
        .section-header {
            padding: var(--spacing-md);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
        }

        /* Results Table - Major readability improvements */
        .results-table-container {
            overflow-x: auto;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--bg-primary);
        }

        .results-table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .results-table-container::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .results-table-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .results-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: var(--font-size-md);
        }

        .results-table thead { 
            position: sticky; 
            top: 0; 
            z-index: 10; 
        }

        .results-table th {
            background: var(--bg-tertiary);
            padding: 14px 14px;
            text-align: left;
            font-weight: 700;
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-muted);
            border-bottom: 2px solid var(--accent-cyan);
            white-space: nowrap;
        }

        .results-table th.center, .results-table td.center { text-align: center; }
        .results-table th.right, .results-table td.right { text-align: right; }

        .results-table tbody tr { 
            transition: background 0.15s ease;
            height: var(--row-height);
        }
        .results-table tbody tr:nth-child(odd) { background: var(--bg-row-odd); }
        .results-table tbody tr:nth-child(even) { background: var(--bg-row-even); }
        .results-table tbody tr:hover { 
            background: var(--bg-row-hover);
        }
        .results-table tbody tr.clickable-row { cursor: pointer; }

        .results-table td {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border-subtle);
            white-space: nowrap;
            font-size: var(--font-size-md);
            font-weight: 500;
            vertical-align: middle;
            color: var(--text-data);
        }

        /* Position column */
        .position {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1.2rem;
            width: 3.5rem;
            text-align: center;
            color: var(--text-bright);
        }

        .position.p1 { color: #ffd700; text-shadow: 0 0 12px rgba(255, 215, 0, 0.6); }
        .position.p2 { color: #e8e8e8; text-shadow: 0 0 10px rgba(200, 200, 200, 0.5); }
        .position.p3 { color: #e8a050; text-shadow: 0 0 10px rgba(232, 160, 80, 0.5); }

        /* Car Number */
        .car-number {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            padding: 6px 12px;
            border-radius: 4px;
            background: linear-gradient(135deg, var(--accent-red) 0%, #cc2233 100%);
            color: #fff;
            display: inline-block;
            min-width: 3.2rem;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* Lap Times - Clear monospace display */
        .lap-time { 
            font-family: 'Roboto Mono', monospace; 
            font-size: var(--font-size-timing);
            font-weight: 500;
            letter-spacing: 0.5px;
            color: var(--text-bright);
        }
        .lap-time.best { 
            color: var(--color-best-overall); 
            font-weight: 700;
            text-shadow: 0 0 10px rgba(204, 68, 255, 0.5);
        }
        .lap-time.personal-best { 
            color: var(--color-best-personal);
            font-weight: 600;
            text-shadow: 0 0 8px rgba(0, 221, 102, 0.4);
        }

        /* Gap/Interval display */
        .gap-time {
            font-family: 'Roboto Mono', monospace;
            font-size: var(--font-size-timing);
            font-weight: 500;
            color: var(--color-gap);
        }
        
        .interval-time {
            font-family: 'Roboto Mono', monospace;
            font-size: var(--font-size-timing);
            font-weight: 500;
            color: var(--color-interval);
        }

        /* Driver/Team names */
        .driver-name {
            font-weight: 600;
            color: var(--text-bright);
            font-size: var(--font-size-md);
        }
        
        .team-name {
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        /* Sidebar Panels */
        .sidebar-panel {
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .panel-header {
            padding: 14px var(--spacing-md);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: var(--font-size-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
        }

        .panel-content { 
            padding: var(--spacing-md); 
        }

        /* Statistics - larger and clearer */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-md);
        }

        .stat-item { 
            text-align: center;
            padding: var(--spacing-sm);
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        .stat-value { 
            font-family: 'Orbitron', sans-serif; 
            font-size: 2rem; 
            font-weight: 700;
            color: var(--accent-cyan);
            line-height: 1.2;
        }
        .stat-label { 
            font-size: var(--font-size-xs); 
            color: var(--text-muted); 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            margin-top: 6px;
            font-weight: 600;
        }

        /* Messages - clearer text */
        .message-item {
            padding: 14px 16px;
            border-radius: 6px;
            margin-bottom: var(--spacing-sm);
            font-weight: 600;
            font-size: var(--font-size-md);
            line-height: 1.5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ffffff;
        }

        /* Loading state */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .spinner {
            width: 44px;
            height: 44px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-red);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--spacing-md);
        }

        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Update animations - less intrusive */
        @keyframes updatePulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 12px 2px rgba(0, 255, 136, 0.3); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.1); }
        }
        
        .recently-updated {
            animation: updatePulse 2s ease-in-out 3; /* Only pulse 3 times */
            position: relative;
        }
        
        .recently-updated::after {
            content: '‚óè';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--accent-green);
            font-size: 8px;
            animation: blink 1s infinite 3; /* Stop after 3 blinks */
        }
        
        .update-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-green);
            margin-left: 6px;
            animation: blink 1s infinite 5;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { 
            background: var(--bg-tertiary); 
            border-radius: 5px;
            border: 2px solid var(--bg-primary);
        }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-color); }
        
        /* Selection styling */
        ::selection {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }
        
        /* Focus states for accessibility */
        button:focus, input:focus, select:focus {
            outline: 2px solid var(--accent-cyan);
            outline-offset: 2px;
        }
        
        /* Better link styling */
        a {
            color: var(--accent-cyan);
            text-decoration: none;
            transition: color 0.2s;
        }
        a:hover {
            color: var(--accent-green);
            text-decoration: underline;
        }
        
        /* Numeric values should be tabular for alignment */
        .tabular-nums {
            font-variant-numeric: tabular-nums;
        }
        
        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --bg-primary: #000000;
                --bg-secondary: #0a0a0a;
                --text-primary: #ffffff;
                --border-color: #444444;
            }
        }
        
        /* Print styles */
        @media print {
            body {
                background: white;
                color: black;
            }
            .header, .sidebar, .position-graph-section, .modal {
                display: none !important;
            }
            .results-table {
                font-size: 10pt;
            }
            .results-table th, .results-table td {
                border: 1px solid #ccc;
                padding: 4px;
            }
        }
    </style>
</head>
<body>
    <!-- Connection Modal -->
    <div class="modal" id="connectionModal">
        <div class="modal-content">
            <h2>üèéÔ∏è Connect to Live Timing</h2>
            <p>Paste the WebSocket URL from getraceresults.com to connect:</p>
            
            <div class="instructions">
                <strong>How to get the WebSocket URL:</strong>
                <ol>
                    <li>Open <a href="https://livetiming.getraceresults.com/demo2" target="_blank" style="color: var(--accent-green);">livetiming.getraceresults.com/demo2</a> in a new tab</li>
                    <li>Press F12 to open Developer Tools</li>
                    <li>Go to the <strong>Network</strong> tab</li>
                    <li>Filter by <strong>WS</strong> (WebSockets)</li>
                    <li>Refresh the page (F5)</li>
                    <li>Click on the <strong>connect</strong> entry</li>
                    <li>Copy the full <strong>Request URL</strong></li>
                </ol>
            </div>
            
            <input type="text" id="wsUrlInput" placeholder="wss://livetiming.getraceresults.com/lt/connect?transport=webSockets&..." value="wss://livetiming.getraceresults.com/lt/connect?transport=webSockets&amp;clientProtocol=1.5&amp;_tk=84992738a8304d15a8f20722b7a27947&amp;_gr=w&amp;_tkdm=1041140&amp;connectionToken=FWT09RJEOFAHDbxfUngcCCb1h6UM6Yy0rx%2BBv0jXaVEC5KnepwdkWeHqZh58rBQmrV1hEAOpLQbfzrSUbMLBjHrrRU0NjN1kSovhFcPmOY%2BQxqWcOvb4ua56RpUtVb1O&amp;tid=6">
            <button onclick="connectWithUrl()">Connect</button>
        </div>
    </div>
    
    <!-- Fullscreen Battle View Modal -->
    <div class="modal hidden" id="battleModal">
        <div style="width: 95vw; height: 95vh; background: var(--bg-secondary); border-radius: 10px; border: 1px solid var(--border-color); display: flex; flex-direction: column; overflow: hidden;">
            <!-- Header -->
            <div style="padding: 15px 20px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h2 style="font-family: 'Orbitron', sans-serif; font-size: 18px; color: var(--accent-red);">‚öîÔ∏è BATTLE OVERVIEW</h2>
                    <span id="battleModalRaceName" style="color: var(--text-secondary);"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <label style="font-size: 12px; color: var(--text-muted);">Group by:</label>
                    <select id="battleModalGroupBy" onchange="updateFullscreenBattles()" style="padding: 6px 10px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                        <option value="position">Position</option>
                        <option value="class">Class</option>
                        <option value="battles">Hot Battles Only</option>
                    </select>
                    <button onclick="closeFullscreenBattles()" style="padding: 8px 16px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif;">‚úï CLOSE</button>
                </div>
            </div>
            
            <!-- Content -->
            <div id="battleModalContent" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- Car cards -->
                <div id="battleCardsContainer">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Track View Modal -->
    <div class="modal hidden" id="trackFullscreenModal">
        <div style="width: 95vw; height: 95vh; background: var(--bg-secondary); border-radius: 10px; border: 1px solid var(--border-color); display: flex; flex-direction: column; overflow: hidden;">
            <!-- Header -->
            <div style="padding: 15px 20px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h2 style="font-family: 'Orbitron', sans-serif; font-size: 18px; color: var(--accent-green);">üèÅ TRACK POSITION</h2>
                    <span id="trackModalRaceName" style="color: var(--text-secondary);"></span>
                </div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <label style="font-size: 12px; color: var(--text-muted);">Filter:</label>
                    <input type="text" id="trackModalFilter" placeholder="e.g. 3, 12, 5, 27" 
                           onkeyup="updateTrackFullscreen()"
                           style="width: 150px; padding: 6px 10px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 11px;">
                    <button onclick="document.getElementById('trackModalFilter').value=''; updateTrackFullscreen();" style="padding: 6px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; cursor: pointer; font-size: 11px;">Clear</button>
                    <button onclick="closeTrackFullscreen()" style="padding: 8px 16px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif;">‚úï CLOSE</button>
                </div>
            </div>
            
            <!-- Legend -->
            <div id="trackModalLegend" style="padding: 10px 20px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
                <!-- Populated by JS -->
            </div>
            
            <!-- Content -->
            <div style="flex: 1; display: flex; overflow: hidden;">
                <!-- Track View -->
                <div id="trackModalGraph" style="flex: 2; position: relative; background: radial-gradient(circle at center, #1a1a2e 0%, #0d0d1a 100%); overflow: hidden;">
                    <!-- Track will be rendered here -->
                </div>
                
                <!-- Hover Info Panel -->
                <div id="trackModalInfo" style="width: 320px; background: var(--bg-tertiary); border-left: 1px solid var(--border-color); padding: 15px; overflow-y: auto;">
                    <div style="text-align: center; color: var(--text-muted); padding: 40px 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üëÜ</div>
                        <div>Hover over a car to see details</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Car Analysis Modal -->
    <div class="modal hidden" id="carAnalysisModal">
        <div style="width: 95vw; height: 95vh; background: var(--bg-secondary); border-radius: 10px; border: 1px solid var(--border-color); display: flex; flex-direction: column; overflow: hidden;">
            <!-- Header -->
            <div style="padding: 15px 20px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h2 style="font-family: 'Orbitron', sans-serif; font-size: 18px; color: var(--accent-blue);">üìä CAR ANALYSIS</h2>
                    <div id="analysisCarBadges" style="display: flex; gap: 8px;">
                        <!-- Car badges will be added here -->
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <button onclick="clearComparison()" style="padding: 6px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; cursor: pointer; font-size: 11px;">Clear All</button>
                    <button onclick="closeCarAnalysis()" style="padding: 8px 16px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif;">‚úï CLOSE</button>
                </div>
            </div>
            
            <!-- Tabs -->
            <div style="display: flex; border-bottom: 1px solid var(--border-color); background: var(--bg-tertiary);">
                <button id="analysisTabSingle" onclick="setAnalysisTab('single')" style="flex: 1; padding: 12px; background: var(--accent-blue); color: #fff; border: none; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px;">üìã SINGLE CAR</button>
                <button id="analysisTabCompare" onclick="setAnalysisTab('compare')" style="flex: 1; padding: 12px; background: transparent; color: var(--text-muted); border: none; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px;">‚öîÔ∏è HEAD TO HEAD</button>
                <button id="analysisTabLapTimes" onclick="setAnalysisTab('laptimes')" style="flex: 1; padding: 12px; background: transparent; color: var(--text-muted); border: none; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px;">üìà LAP TIME GRAPH</button>
            </div>
            
            <!-- Content -->
            <div id="analysisContent" style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <!-- Stint Analysis Modal -->
    <div class="modal hidden" id="stintAnalysisModal">
        <div style="width: 95vw; height: 95vh; background: var(--bg-secondary); border-radius: 10px; border: 1px solid var(--border-color); display: flex; flex-direction: column; overflow: hidden;">
            <!-- Header -->
            <div style="padding: 15px 20px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 20px;">
                    <h2 style="font-family: 'Orbitron', sans-serif; font-size: 18px; color: var(--accent-purple);">‚è±Ô∏è STINT ANALYSIS</h2>
                    <select id="stintCarSelect" onchange="renderStintAnalysis()" style="padding: 6px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; min-width: 120px;"></select>
                </div>
                <button onclick="closeStintAnalysis()" style="padding: 8px 16px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif;">‚úï CLOSE</button>
            </div>
            <div id="stintCarInfo" style="padding: 12px 20px; background: var(--bg-primary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 30px;"></div>
            <div id="stintAnalysisContent" style="flex: 1; overflow-y: auto; padding: 20px;"></div>
        </div>
    </div>

    <header class="header">
        <div style="display: flex; align-items: center; gap: 2rem;">
            <div class="logo">LIVE TIMING</div>
            <div class="race-name" id="raceName">Not connected</div>
        </div>
        
        <div class="header-center">
            <div class="flag-indicator not-started" id="flagIndicator">
                <span id="flagText">NOT STARTED</span>
            </div>
            
            <div class="clock-display">
                <div class="clock-label" id="clockLabel">Race Time</div>
                <div class="clock-time" id="clockTime">--:--:--</div>
            </div>
            
            <div class="time-to-go-display" id="timeToGoContainer" style="display: none;">
                <div class="time-to-go-label">Remaining</div>
                <div class="time-to-go-value" id="timeToGo" style="color: var(--accent-yellow);">--:--:--</div>
            </div>
            
            <div class="eta-display" id="etaContainer" style="display: none;">
                <div class="eta-label">ETA</div>
                <div class="eta-value" id="etaTime">--:--</div>
            </div>
            
            <div class="lap-counter">
                <div class="lap-label">Lap</div>
                <div class="lap-value"><span id="currentLap">-</span><span id="totalLaps" style="color: var(--text-muted); font-size: 0.9em;"></span></div>
            </div>
        </div>
        
        <div class="connection-status" onclick="showModal()">
            <div class="connection-dot" id="connectionDot"></div>
            <span id="connectionText">Click to connect</span>
        </div>
    </header>
    
    <main class="main-content">
        <section class="results-section">
            <div class="section-header">
                <h2 class="section-title">Race Results</h2>
                <div id="participantCount">-</div>
            </div>
            <div class="results-table-container">
                <table class="results-table">
                    <thead id="resultsHead">
                        <tr><th>Waiting for connection...</th></tr>
                    </thead>
                    <tbody id="resultsBody">
                        <tr>
                            <td class="loading">
                                <div class="spinner"></div>
                                <div>Click the connection status to connect</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        
        <!-- Position Graph Section -->
        <section class="position-graph-section">
            <div class="position-graph-header">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <span class="section-title" style="margin: 0;">üìä Field Position</span>
                    <div style="display: flex; align-items: center; gap: 4px; background: var(--bg-tertiary); border-radius: 4px; padding: 2px;">
                        <button id="btnLinearView" onclick="setGraphView('linear')" style="padding: 4px 10px; background: var(--accent-green); color: #000; border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;">LINEAR</button>
                        <button id="btnCircularView" onclick="setGraphView('circular')" style="padding: 4px 10px; background: transparent; color: var(--text-muted); border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;">TRACK</button>
                        <button id="btnLapChartView" onclick="setGraphView('lapchart')" style="padding: 4px 10px; background: transparent; color: var(--text-muted); border: none; border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;">LAP CHART</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="font-size: 11px; color: var(--text-muted);">Filter:</label>
                        <input type="text" id="graphCarFilter" placeholder="e.g. 3, 12, 5, 27" 
                               onkeyup="updatePositionGraph()"
                               style="width: 150px; padding: 4px 8px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 11px;">
                        <button onclick="clearGraphFilter()" style="padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; cursor: pointer; font-size: 10px;">Clear</button>
                    </div>
                    <button onclick="openTrackFullscreen()" style="padding: 4px 12px; background: var(--accent-purple); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">‚õ∂ FULLSCREEN</button>
                </div>
                <div id="positionGraphLegend" style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
                    <!-- Legend rendered by JS -->
                </div>
            </div>
            <!-- Linear Graph - Multi-lane layout by class -->
            <div id="positionGraphLinear" style="position: relative; height: 160px; background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%); border-radius: 6px; overflow: visible; margin-top: 10px; border: 1px solid var(--border-color); padding: 10px 0;">
                <!-- Track lanes and cars will be rendered here by JS -->
            </div>
            <!-- Circular Graph -->
            <div id="positionGraphCircular" style="display: none; position: relative; height: 300px; background: radial-gradient(circle at center, var(--bg-primary) 0%, var(--bg-tertiary) 100%); border-radius: 6px; overflow: hidden; margin-top: 10px; border: 1px solid var(--border-color);">
                <!-- Track circles will be rendered here by JS -->
            </div>
            <!-- Lap Chart -->
            <div id="positionGraphLapChart" style="display: none; position: relative; height: 300px; background: var(--bg-tertiary); border-radius: 6px; overflow: hidden; margin-top: 10px; border: 1px solid var(--border-color);">
                <!-- Lap chart will be rendered here by JS -->
            </div>
        </section>
        
        <aside class="sidebar">
            <div class="sidebar-panel">
                <div class="panel-header" style="padding: 0;">
                    <div style="display: flex; border-bottom: 1px solid var(--border-color);">
                        <button id="tabTrackCar" onclick="switchBattleTab('track')" class="battle-tab active" style="flex: 1; padding: 10px; background: transparent; border: none; color: var(--text-primary); cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; border-bottom: 2px solid var(--accent-green);">üéØ TRACK CAR</button>
                        <button id="tabAllBattles" onclick="switchBattleTab('all')" class="battle-tab" style="flex: 1; padding: 10px; background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; border-bottom: 2px solid transparent;">‚öîÔ∏è ALL BATTLES</button>
                    </div>
                </div>
                <div class="panel-content">
                    <!-- Track Car Tab -->
                    <div id="trackCarTab">
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; color: var(--text-muted);">Track Car #</label>
                            <div style="display: flex; gap: 8px; margin-top: 5px;">
                                <input type="text" id="trackCarInput" placeholder="e.g. 26" 
                                       onkeypress="if(event.key==='Enter')setTrackedCar()"
                                       style="flex: 1; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: 'Orbitron', sans-serif;">
                                <button onclick="setTrackedCar()" style="padding: 8px 12px; background: var(--accent-green); color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Track</button>
                            </div>
                        </div>
                        <div id="battleTracker">
                            <div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">
                                Enter a car number to track
                            </div>
                        </div>
                    </div>
                    
                    <!-- All Battles Tab -->
                    <div id="allBattlesTab" style="display: none;">
                        <div style="margin-bottom: 10px; display: flex; gap: 8px; align-items: center; justify-content: space-between;">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <label style="font-size: 11px; color: var(--text-muted);">Threshold:</label>
                                <select id="battleThreshold" onchange="updateAllBattles()" style="padding: 4px 8px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 11px;">
                                    <option value="1">< 1s</option>
                                    <option value="2" selected>< 2s</option>
                                    <option value="3">< 3s</option>
                                    <option value="5">< 5s</option>
                                    <option value="999">All</option>
                                </select>
                            </div>
                            <button onclick="openFullscreenBattles()" style="padding: 4px 10px; background: var(--accent-purple); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;">‚õ∂ FULLSCREEN</button>
                        </div>
                        <div id="allBattlesContainer" style="max-height: 400px; overflow-y: auto;">
                            <div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">
                                Waiting for data...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-panel">
                <div class="panel-header">
                    <h3 class="panel-title">Statistics</h3>
                </div>
                <div class="panel-content">
                    <div class="stat-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="statOnTrack">-</div>
                            <div class="stat-label">On Track</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statInPit">-</div>
                            <div class="stat-label">In Pit</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statTotalLaps">-</div>
                            <div class="stat-label">Total Laps</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="statPitStops">-</div>
                            <div class="stat-label">Pit Stops</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-panel">
                <div class="panel-header">
                    <h3 class="panel-title">Debug Info</h3>
                </div>
                <div class="panel-content" style="font-family: monospace; font-size: 11px;">
                    <div>Headers: <span id="debugHeaders">0</span></div>
                    <div>Rows: <span id="debugRows">0</span></div>
                    <div>Messages received: <span id="debugMsgCount">0</span></div>
                    <div>Last method: <span id="debugLastMethod">-</span></div>
                </div>
            </div>
            
            <div class="sidebar-panel">
                <div class="panel-header">
                    <h3 class="panel-title">üé¨ Recorder <span id="wsRecorderStatus" style="font-size: 10px;">‚ö´</span></h3>
                </div>
                <div class="panel-content" style="font-size: 11px;">
                    <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                        <button id="wsRecordBtn" onclick="wsRecorder.isRecording ? wsRecorder.stopRecording() : wsRecorder.startRecording()" style="flex: 1; padding: 6px 8px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">üî¥ Rec</button>
                        <button onclick="wsRecorder.downloadRecording()" style="flex: 1; padding: 6px 8px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">üíæ Save</button>
                    </div>
                    <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                        <label style="flex: 1; padding: 6px 8px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; text-align: center;">
                            üìÇ Load
                            <input type="file" accept=".json" onchange="wsRecorder.loadRecording(this.files[0])" style="display: none;">
                        </label>
                        <button id="wsReplayBtn" onclick="wsRecorder.isReplaying ? wsRecorder.stopReplay() : wsRecorder.startReplay(parseFloat(document.getElementById('wsReplaySpeed').value) || 1)" style="flex: 1; padding: 6px 8px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">‚ñ∂Ô∏è Play</button>
                    </div>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <span style="color: #888; font-size: 10px;">Speed:</span>
                        <select id="wsReplaySpeed" style="flex: 1; padding: 4px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; font-size: 10px;">
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1x</option>
                            <option value="2">2x</option>
                            <option value="5">5x</option>
                            <option value="10">10x</option>
                            <option value="50">50x</option>
                        </select>
                        <span style="color: #888; font-size: 10px;">Msgs: <span id="wsRecordCount">0</span></span>
                    </div>
                    <div id="wsReplayProgress" style="color: #888; font-size: 10px; margin-top: 5px; text-align: center;"></div>
                </div>
            </div>
            
            <div class="sidebar-panel">
                <div class="panel-header">
                    <h3 class="panel-title">Messages</h3>
                </div>
                <div class="panel-content" id="messagesContainer">
                    <div class="message-item" style="background: rgba(100, 100, 100, 0.3);">
                        Waiting for connection...
                    </div>
                </div>
            </div>
        </aside>
    </main>

    <script>
        // ===========================================
        // WEBSOCKET RECORDING & REPLAY
        // ===========================================
        const wsRecorder = {
            isRecording: false,
            isReplaying: false,
            recordings: [],
            startTime: null,
            replayIndex: 0,
            replayTimeouts: [],
            autoSaveInterval: null,
            autoSaveMinutes: 5,  // Auto-save every 5 minutes
            lastAutoSave: 0,
            
            startRecording() {
                this.recordings = [];
                this.startTime = Date.now();
                this.isRecording = true;
                this.lastAutoSave = Date.now();
                
                // Start autosave timer
                this.autoSaveInterval = setInterval(() => {
                    if (this.isRecording && this.recordings.length > 0) {
                        this.autoSave();
                    }
                }, this.autoSaveMinutes * 60 * 1000);
                
                console.log(`%c[WSRecorder] üî¥ Recording started (autosave every ${this.autoSaveMinutes} min)`, 'color: #ff0000; font-weight: bold');
                this.updateUI();
            },
            
            stopRecording() {
                this.isRecording = false;
                
                // Clear autosave timer
                if (this.autoSaveInterval) {
                    clearInterval(this.autoSaveInterval);
                    this.autoSaveInterval = null;
                }
                
                // Final autosave
                if (this.recordings.length > 0) {
                    this.autoSave();
                }
                
                console.log(`%c[WSRecorder] ‚èπÔ∏è Recording stopped. ${this.recordings.length} messages captured`, 'color: #ff6600; font-weight: bold');
                this.updateUI();
            },
            
            autoSave() {
                if (this.recordings.length === 0) return;
                
                const now = Date.now();
                const duration = this.recordings[this.recordings.length - 1].t;
                
                // Save to localStorage (keep last recording)
                try {
                    const data = {
                        version: 1,
                        recordedAt: new Date(this.startTime).toISOString(),
                        autoSavedAt: new Date().toISOString(),
                        duration: duration,
                        messageCount: this.recordings.length,
                        messages: this.recordings
                    };
                    
                    // Try localStorage first (limit ~5MB)
                    const jsonStr = JSON.stringify(data);
                    if (jsonStr.length < 4 * 1024 * 1024) { // < 4MB
                        localStorage.setItem('wsRecording_autosave', jsonStr);
                        console.log(`%c[WSRecorder] üíæ Auto-saved to localStorage (${this.recordings.length} msgs, ${(jsonStr.length/1024/1024).toFixed(2)}MB)`, 'color: #00bcd4');
                    } else {
                        // Too big for localStorage, trigger download
                        console.log(`%c[WSRecorder] üíæ Recording too large for localStorage, downloading...`, 'color: #ffcc00');
                        this.downloadRecording(true);
                    }
                    
                    this.lastAutoSave = now;
                    this.updateUI();
                } catch (e) {
                    console.warn('[WSRecorder] Auto-save failed:', e.message);
                    // Fallback: download file
                    this.downloadRecording(true);
                }
            },
            
            recordMessage(rawMessage) {
                if (!this.isRecording) return;
                
                const elapsed = Date.now() - this.startTime;
                this.recordings.push({
                    t: elapsed,  // Time offset in ms
                    d: rawMessage // Raw message data
                });
                
                // Update count in UI every 100 messages
                if (this.recordings.length % 100 === 0) {
                    const countEl = document.getElementById('wsRecordCount');
                    if (countEl) countEl.textContent = this.recordings.length;
                }
            },
            
            downloadRecording(isAutoSave = false) {
                if (this.recordings.length === 0) {
                    if (!isAutoSave) alert('No recordings to download');
                    return;
                }
                
                const data = {
                    version: 1,
                    recordedAt: new Date(this.startTime || Date.now()).toISOString(),
                    duration: this.recordings[this.recordings.length - 1].t,
                    messageCount: this.recordings.length,
                    messages: this.recordings
                };
                
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const prefix = isAutoSave ? 'ws-autosave' : 'ws-recording';
                a.download = `${prefix}-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                const msg = isAutoSave ? 'üíæ Auto-saved' : 'üíæ Downloaded';
                console.log(`%c[WSRecorder] ${msg} ${this.recordings.length} messages (${(blob.size/1024/1024).toFixed(2)}MB)`, 'color: #00ff00; font-weight: bold');
            },
            
            // Load from localStorage autosave
            loadAutoSave() {
                try {
                    const saved = localStorage.getItem('wsRecording_autosave');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.recordings = data.messages;
                        console.log(`%c[WSRecorder] üìÇ Loaded autosave: ${this.recordings.length} messages from ${data.autoSavedAt || data.recordedAt}`, 'color: #00bcd4; font-weight: bold');
                        this.updateUI();
                        return true;
                    }
                } catch (e) {
                    console.warn('[WSRecorder] Failed to load autosave:', e);
                }
                return false;
            },
            
            clearAutoSave() {
                localStorage.removeItem('wsRecording_autosave');
                console.log('[WSRecorder] Cleared autosave from localStorage');
            },
            
            async loadRecording(file) {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (!data.messages || !Array.isArray(data.messages)) {
                        throw new Error('Invalid recording format');
                    }
                    
                    this.recordings = data.messages;
                    console.log(`%c[WSRecorder] üìÇ Loaded ${this.recordings.length} messages (${(data.duration/1000/60).toFixed(1)} minutes)`, 'color: #00bcd4; font-weight: bold');
                    this.updateUI();
                    alert(`Loaded ${this.recordings.length} messages (${(data.duration/1000/60).toFixed(1)} minutes). Click Play to start replay.`);
                    
                    return true;
                } catch (e) {
                    console.error('[WSRecorder] Failed to load recording:', e);
                    alert('Failed to load recording: ' + e.message);
                    return false;
                }
            },
            
            startReplay(speedMultiplier = 1) {
                if (this.recordings.length === 0) {
                    alert('No recording loaded. Load a recording first.');
                    return;
                }
                
                // Stop any existing replay
                this.stopReplay();
                
                // Disconnect live WebSocket
                const activeWs = (typeof Store !== 'undefined' && Store.connection.ws) || (typeof ws !== 'undefined' && ws);
                if (activeWs && activeWs.readyState === WebSocket.OPEN) {
                    activeWs.close();
                    console.log('[WSRecorder] Disconnected live WebSocket for replay');
                }
                
                this.isReplaying = true;
                this.replayIndex = 0;
                
                console.log(`%c[WSRecorder] ‚ñ∂Ô∏è Replay started (${speedMultiplier}x speed, ${this.recordings.length} messages)`, 'color: #00ff00; font-weight: bold');
                this.updateUI();
                
                // Schedule all messages
                this.recordings.forEach((rec, idx) => {
                    const delay = rec.t / speedMultiplier;
                    const timeout = setTimeout(() => {
                        if (!this.isReplaying) return;
                        
                        this.replayIndex = idx + 1;
                        
                        // Process the message as if it came from WebSocket
                        try {
                            const parsed = typeof rec.d === 'string' ? JSON.parse(rec.d) : rec.d;
                            if (parsed.M) {
                                parsed.M.forEach(m => processHubMessage(m));
                            } else {
                                processHubMessage(parsed);
                            }
                        } catch (e) {
                            console.warn('[WSRecorder] Error processing message:', e);
                        }
                        
                        // Update progress every 50 messages
                        if (idx % 50 === 0 || idx === this.recordings.length - 1) {
                            const progressEl = document.getElementById('wsReplayProgress');
                            if (progressEl) {
                                const pct = ((idx + 1) / this.recordings.length * 100).toFixed(1);
                                progressEl.textContent = `${idx + 1}/${this.recordings.length} (${pct}%)`;
                            }
                        }
                        
                        // Check if done
                        if (idx === this.recordings.length - 1) {
                            console.log('%c[WSRecorder] ‚úÖ Replay finished', 'color: #00ff00; font-weight: bold');
                            this.isReplaying = false;
                            this.updateUI();
                        }
                    }, delay);
                    
                    this.replayTimeouts.push(timeout);
                });
            },
            
            stopReplay() {
                this.isReplaying = false;
                this.replayTimeouts.forEach(t => clearTimeout(t));
                this.replayTimeouts = [];
                if (this.replayIndex > 0) {
                    console.log('%c[WSRecorder] ‚èπÔ∏è Replay stopped', 'color: #ff6600; font-weight: bold');
                }
                this.updateUI();
            },
            
            updateUI() {
                const recordBtn = document.getElementById('wsRecordBtn');
                const replayBtn = document.getElementById('wsReplayBtn');
                const statusEl = document.getElementById('wsRecorderStatus');
                const countEl = document.getElementById('wsRecordCount');
                
                if (recordBtn) {
                    if (this.isRecording) {
                        recordBtn.textContent = '‚èπÔ∏è Stop';
                        recordBtn.style.background = '#ff4444';
                    } else {
                        recordBtn.textContent = 'üî¥ Rec';
                        recordBtn.style.background = '#333';
                    }
                }
                
                if (replayBtn) {
                    if (this.isReplaying) {
                        replayBtn.textContent = '‚èπÔ∏è Stop';
                        replayBtn.style.background = '#44ff44';
                        replayBtn.style.color = '#000';
                    } else {
                        replayBtn.textContent = '‚ñ∂Ô∏è Play';
                        replayBtn.style.background = '#333';
                        replayBtn.style.color = '#fff';
                    }
                }
                
                if (countEl) {
                    countEl.textContent = this.recordings.length;
                }
                
                if (statusEl) {
                    if (this.isRecording) {
                        statusEl.textContent = 'üî¥ REC';
                        statusEl.style.color = '#ff4444';
                    } else if (this.isReplaying) {
                        statusEl.textContent = '‚ñ∂Ô∏è PLAY';
                        statusEl.style.color = '#44ff44';
                    } else if (this.recordings.length > 0) {
                        statusEl.textContent = `üìº ${this.recordings.length}`;
                        statusEl.style.color = '#00bcd4';
                    } else {
                        statusEl.textContent = '‚ö´';
                        statusEl.style.color = '#666';
                    }
                }
            }
        };
        
        // Make available globally
        window.wsRecorder = wsRecorder;
        
        // Check for autosave on load
        setTimeout(() => {
            const saved = localStorage.getItem('wsRecording_autosave');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    const mins = (data.duration / 1000 / 60).toFixed(1);
                    if (confirm(`Found autosaved recording:\n${data.messageCount} messages (${mins} min)\nFrom: ${data.autoSavedAt || data.recordedAt}\n\nLoad it?`)) {
                        wsRecorder.loadAutoSave();
                    }
                } catch (e) {}
            }
        }, 2000);

        // ===========================================
        // CORE: Central Store (Single Source of Truth)
        // ===========================================
        const Store = {
            // Connection state
            connection: {
                ws: null,
                connected: false,
                url: null,
                retryCount: 0
            },
            
            // Session/Heat state
            session: {
                name: '',
                flag: null,
                flagClass: 'not-started',
                flagText: 'NOT STARTED',
                startTime: null,
                endTime: null,
                currentTime: null,
                elapsedTime: 0,
                timeLength: null,
                lapsLength: null,
                leaderLap: 0,
                lengthMode: null,
                clockHaltedDuration: 0,
                lastUpdateRealTime: 0
            },
            
            // Cars Map: carNum -> carState
            cars: new Map(),
            
            // Table structure
            headers: [],
            
            // Messages from race control
            messages: [],
            
            // Statistics
            stats: {
                onTrack: 0,
                inPit: 0,
                totalLaps: 0,
                pitStops: 0,
                participants: 0
            },
            
            // UI state
            ui: {
                trackedCarNumber: null,
                graphViewMode: 'linear',
                currentBattleTab: 'track',
                currentAnalysisTab: 'single',
                comparisonCars: []
            },
            
            // Position history for lap chart (by leader lap)
            positionHistory: {},
            lastRecordedLap: 0,
            
            // Reset on reconnect
            reset() {
                this.cars.clear();
                this.messages = [];
                this.headers = [];
                this.positionHistory = {};
                this.lastRecordedLap = 0;
            }
        };
        
        // ===========================================
        // CORE: Car State Factory
        // ===========================================
        const MAX_HISTORY = 200; // Cap for endurance races
        
        function getCar(carNum) {
            if (!Store.cars.has(carNum)) {
                Store.cars.set(carNum, {
                    carNum: carNum,
                    // Current state
                    pos: 999,
                    posInClass: null,
                    lap: 0,
                    state: null,
                    // Raw row data (for table display)
                    data: {},
                    meta: {},
                    // Timing
                    lastLapTime: null,
                    bestLapTime: null,
                    bestLapNum: null,
                    sectors: { s1: null, s2: null, s3: null },
                    pendingSectors: { s1: null, s2: null, s3: null },
                    // Gaps
                    gapToLeader: null,
                    gapToAhead: null,
                    // History (capped)
                    history: {
                        laps: [],      // [{ lap, time, s1, s2, s3, pos, timestamp }]
                        positions: [], // [{ lap, pos }]
                        gaps: []       // [{ timestamp, ahead, behind }]
                    },
                    // Pit stops
                    pitStops: [],
                    lastPitTime: null,
                    stintStart: null,
                    // Updates
                    updatedAt: 0,
                    updatedFields: []
                });
            }
            return Store.cars.get(carNum);
        }
        
        // Push with cap for memory safety
        function pushCapped(arr, item, max = MAX_HISTORY) {
            arr.push(item);
            if (arr.length > max) arr.shift();
        }
        
        // ===========================================
        // CORE: Render Queue (Batched Updates)
        // ===========================================
        const RenderQueue = new Set();
        let framePending = false;
        
        function requestRender(fn) {
            RenderQueue.add(fn);
            if (framePending) return;
            
            framePending = true;
            requestAnimationFrame(() => {
                RenderQueue.forEach(f => {
                    try { f(); } catch(e) { console.error('[Render Error]', e); }
                });
                RenderQueue.clear();
                framePending = false;
            });
        }
        
        // ===========================================
        // UTILS: Time Formatting
        // ===========================================
        const flagClasses = {
            '-1': 'not-started', '0': 'not-started', '1': 'not-started',
            '2': 'red', '3': 'yellow', '4': 'yellow',
            '5': 'checkered', '6': 'green', '7': 'yellow', '8': 'code60'
        };
        
        const flagTexts = {
            '-1': 'NOT STARTED', '0': 'NOT STARTED', '1': 'READY',
            '2': 'RED FLAG', '3': 'YELLOW', '4': 'FCY',
            '5': 'FINISHED', '6': 'GREEN', '7': 'SC', '8': 'CODE 60'
        };
        
        // ===========================================
        // LEGACY: Compatibility layer (to be removed)
        // These variables point to Store for gradual migration
        // ===========================================
        let ws = null;  // Will use Store.connection.ws
        let headers = Store.headers;
        let rows = [];  // Will be derived from Store.cars
        let heatState = Store.session;
        let statistics = Store.stats;
        let messages = Store.messages;
        let trackedCarNumber = null;
        let gapHistory = {};
        const GAP_HISTORY_SIZE = 10;
        let recentUpdates = {};
        let graphViewMode = 'linear';
        let currentSessionTime = 0;
        let positionHistory = Store.positionHistory;
        let lastRecordedLap = 0;
        let carHistory = {};
        let pendingSectors = {};
        let comparisonCars = [];
        
        // ===========================================
        // DOM Elements Cache
        // ===========================================
        const el = {
            modal: document.getElementById('connectionModal'),
            wsUrlInput: document.getElementById('wsUrlInput'),
            raceName: document.getElementById('raceName'),
            flagIndicator: document.getElementById('flagIndicator'),
            flagText: document.getElementById('flagText'),
            clockTime: document.getElementById('clockTime'),
            clockLabel: document.getElementById('clockLabel'),
            timeToGoContainer: document.getElementById('timeToGoContainer'),
            timeToGo: document.getElementById('timeToGo'),
            etaContainer: document.getElementById('etaContainer'),
            etaTime: document.getElementById('etaTime'),
            currentLap: document.getElementById('currentLap'),
            totalLaps: document.getElementById('totalLaps'),
            resultsHead: document.getElementById('resultsHead'),
            resultsBody: document.getElementById('resultsBody'),
            participantCount: document.getElementById('participantCount'),
            statOnTrack: document.getElementById('statOnTrack'),
            statInPit: document.getElementById('statInPit'),
            statTotalLaps: document.getElementById('statTotalLaps'),
            statPitStops: document.getElementById('statPitStops'),
            messagesContainer: document.getElementById('messagesContainer'),
            connectionDot: document.getElementById('connectionDot'),
            connectionText: document.getElementById('connectionText')
        };
        
        // Row cache for DOM efficiency
        const rowCache = new Map();
        
        // Helper functions
        function formatTime(microseconds) {
            if (!microseconds || microseconds <= 0 || microseconds > 9999999999) return '';
            const totalSeconds = microseconds / 1000000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = (totalSeconds % 60).toFixed(3);
            return `${minutes}:${seconds.padStart(6, '0')}`;
        }
        
        function formatRaceTime(microseconds) {
            if (!microseconds || microseconds <= 0) return '--:--:--';
            const totalSeconds = microseconds / 1000000;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function formatSectorTime(microseconds) {
            if (!microseconds || microseconds <= 0 || microseconds > 999999999999) return '';
            const totalSeconds = microseconds / 1000000;
            return totalSeconds.toFixed(3);
        }
        
        // Format stint time - handles start timestamp (S prefix) or duration
        function formatStintTime(value) {
            if (!value) return '';
            
            const str = String(value).trim();
            
            // Check for 'S' prefix indicating start timestamp
            if (str.startsWith('S')) {
                const startTime = parseInt(str.substring(1), 10);
                if (!isNaN(startTime) && currentSessionTime > 0) {
                    // Calculate duration: current time - start time
                    const duration = currentSessionTime - startTime;
                    if (duration > 0) {
                        return formatDuration(duration);
                    }
                }
                return '--:--'; // Can't calculate yet
            }
            
            // Check for 'L' prefix indicating last pit duration (direct microseconds)
            if (str.startsWith('L')) {
                const duration = parseInt(str.substring(1), 10);
                if (!isNaN(duration) && duration > 0 && duration < 999999999999) {
                    return formatPitDuration(duration);
                }
                return '--:--';
            }
            
            // Regular duration value (microseconds)
            const rawVal = parseInt(str, 10);
            if (!isNaN(rawVal) && rawVal > 1000000 && rawVal < 999999999999) {
                return formatDuration(rawVal);
            }
            
            // Already formatted or unknown format
            return str;
        }
        
        // Format pit duration in microseconds to mm:ss.sss (shows milliseconds for pit stops)
        function formatPitDuration(microseconds) {
            const totalMs = Math.floor(microseconds / 1000);
            const ms = totalMs % 1000;
            const totalSec = Math.floor(totalMs / 1000);
            const sec = totalSec % 60;
            const min = Math.floor(totalSec / 60);
            
            if (min > 0) {
                return `${min}:${String(sec).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
            }
            return `${sec}.${String(ms).padStart(3, '0')}`;
        }
        
        // Format duration in microseconds to mm:ss or h:mm:ss
        function formatDuration(microseconds) {
            const totalSec = Math.floor(microseconds / 1000000);
            const sec = totalSec % 60;
            const totalMin = Math.floor(totalSec / 60);
            const min = totalMin % 60;
            const hours = Math.floor(totalMin / 60);
            
            if (hours > 0) {
                return `${hours}:${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            }
            return `${min}:${String(sec).padStart(2, '0')}`;
        }
        
        function intToRgb(value) {
            if (value === undefined || value === null || value < 0) return null;
            const b = value & 255;
            const g = (value >> 8) & 255;
            const r = (value >> 16) & 255;
            return `${r},${g},${b}`;
        }
        
        // Modal functions
        function showModal() {
            el.modal.classList.remove('hidden');
        }
        
        function hideModal() {
            el.modal.classList.add('hidden');
        }
        
        function connectWithUrl() {
            const url = el.wsUrlInput.value.trim();
            if (!url) {
                alert('Please enter a WebSocket URL');
                return;
            }
            
            if (!url.startsWith('wss://')) {
                alert('URL must start with wss://');
                return;
            }
            
            hideModal();
            connect(url);
        }
        
        // WebSocket connection
        function connect(url) {
            // Close existing connection
            if (Store.connection.ws) {
                Store.connection.ws.close();
            }
            
            Store.connection.url = url;
            setConnectionStatus(false, 'Connecting...');
            console.log('Connecting to:', url.substring(0, 100) + '...');
            
            const socket = new WebSocket(url);
            Store.connection.ws = socket;
            ws = socket; // Legacy compatibility
            
            socket.onopen = function() {
                console.log('WebSocket connected');
                Store.connection.connected = true;
                Store.connection.retryCount = 0;
                setConnectionStatus(true, 'Connected');
            };
            
            socket.onmessage = function(event) {
                const data = event.data;
                if (!data || data === '{}') return;
                
                // Record raw message for replay
                wsRecorder.recordMessage(data);
                
                try {
                    const message = JSON.parse(data);
                    
                    if (message.M && Array.isArray(message.M)) {
                        message.M.forEach(m => processHubMessage(m));
                    }
                } catch (e) {
                    console.log('Parse error:', e);
                }
            };
            
            socket.onclose = function(event) {
                console.log('WebSocket closed:', event.code);
                Store.connection.connected = false;
                
                // Auto-reconnect with exponential backoff (max 30s)
                if (Store.connection.url && event.code !== 1000) {
                    const delay = Math.min(30000, 1000 * Math.pow(2, Store.connection.retryCount));
                    Store.connection.retryCount++;
                    setConnectionStatus(false, `Reconnecting in ${Math.round(delay/1000)}s...`);
                    setTimeout(() => {
                        if (!Store.connection.connected) {
                            connect(Store.connection.url);
                        }
                    }, delay);
                } else {
                    setConnectionStatus(false, 'Disconnected - click to reconnect');
                }
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error');
                Store.connection.connected = false;
                setConnectionStatus(false, 'Error - reconnecting...');
            };
        }
        
        function disconnect() {
            Store.connection.url = null; // Prevent auto-reconnect
            if (Store.connection.ws) {
                Store.connection.ws.close(1000); // Normal closure
            }
        }
        
        function setConnectionStatus(connected, text) {
            el.connectionDot.classList.toggle('connected', connected);
            el.connectionText.textContent = text;
        }
        
        // ===========================================
        // PROTOCOL: Message Handlers
        // ===========================================
        const messageHandlers = {
            // Heat/Session state
            'h_i': (args) => {
                handleHeatState(args[0]);
            },
            'h_h': (args) => {
                handleHeatState(args[0]);
            },
            
            // Results init
            'r_i': (args) => {
                rows = [];
                Store.cars.clear();
                rowCache.clear();
                
                if (args[0]?.l?.h) {
                    headers = args[0].l.h.map(h => {
                        let key = h.n ? h.n.toLowerCase().replace(/\s/g, '_') : '';
                        if (h.p) key += '_' + h.p;
                        return { name: h.n || '', caption: h.c || '', key: key };
                    });
                    Store.headers = headers;
                    console.log('Headers:', headers.map(h => h.key));
                }
                if (args[0]?.r) processResultsCells(args[0].r);
                requestRender(renderResults);
            },
            
            // Results layout
            'r_l': (args) => {
                if (args[0]?.h) {
                    headers = args[0].h.map(h => {
                        let key = h.n ? h.n.toLowerCase().replace(/\s/g, '_') : '';
                        if (h.p) key += '_' + h.p;
                        return { name: h.n || '', caption: h.c || '', key: key };
                    });
                    Store.headers = headers;
                }
                requestRender(renderResults);
            },
            
            // Results cell update
            'r_c': (args) => {
                if (Array.isArray(args[0])) {
                    processResultsCells(args[0]);
                    requestRender(renderResults);
                }
            },
            
            // Results delete rows
            'r_d': (args) => {
                const count = parseInt(args[0], 10);
                if (!isNaN(count)) rows = rows.slice(0, count);
                requestRender(renderResults);
            },
            
            // Statistics
            'a_i': (args) => handleStatistics(args[0]),
            'a_u': (args) => handleStatistics(args[0]),
            
            // Messages init
            'm_i': (args) => {
                console.log('[m_i] Messages init received:', args);
                messages = [];
                Store.messages = [];
                if (Array.isArray(args[0])) {
                    console.log('[m_i] Processing', args[0].length, 'messages');
                    if (args[0].length > 0) {
                        console.log('[m_i] First message sample:', args[0][0]);
                    }
                    args[0].forEach(m => {
                        const msg = { id: m.Id, t: m.t, bc: intToRgb(m.bc), fc: intToRgb(m.fc) };
                        messages.push(msg);
                        Store.messages.push(msg);
                    });
                }
                requestRender(renderMessages);
            },
            
            // Message change
            'm_c': (args) => {
                console.log('[m_c] New message received:', args);
                if (args[0]) {
                    const msg = { id: args[0].Id, t: args[0].t, bc: intToRgb(args[0].bc), fc: intToRgb(args[0].fc) };
                    messages.push(msg);
                    pushCapped(Store.messages, msg, 50);
                    requestRender(renderMessages);
                }
            },
            
            // Messages clear
            'm_a': () => {
                messages = [];
                Store.messages = [];
                requestRender(renderMessages);
            },
            
            // Server time
            's_t': () => { /* Clock sync - future use */ },
            
            // Compressed bulk init
            '_': (args) => {
                console.log('[_] Compressed init message received, length:', args[0]?.length);
                if (args[0] && typeof args[0] === 'string') {
                    try {
                        let decompressed = LZString.decompressFromUTF16(args[0]);
                        if (!decompressed) decompressed = LZString.decompress(args[0]);
                        
                        if (decompressed) {
                            console.log('[_] Decompressed length:', decompressed.length);
                            const data = JSON.parse(decompressed);
                            console.log('[_] Parsed data:', Object.keys(data));
                            processBulkInit(data);
                        }
                    } catch (e) {
                        console.error('[_] Failed to decompress:', e);
                    }
                }
            },
            
            // Tracker messages - use real GPS/position data
            't_i': (args) => {
                console.log('[Tracker Init]', args);
            },
            't_p': (args) => {
                // Tracker position update - real position data!
                // Format: [position, carNum, trackPos, timing?, sector, speed?, inPit, timestamp]
                if (args && args.length > 0 && Array.isArray(args[0])) {
                    args[0].forEach(entry => {
                        if (Array.isArray(entry) && entry.length >= 7) {
                            const carNum = String(entry[1]);
                            const trackPos = entry[2];      // Track position value
                            const sector = entry[4];        // Current sector (1, 2, 3)
                            const inPit = entry[6];         // In pit boolean
                            
                            // Store in animation state
                            let carState = trackAnimationState.cars.get(carNum);
                            if (carState) {
                                // Convert trackPos to 0-1 range
                                // Assuming trackPos is in range 0-10000000 (or similar)
                                // We need to figure out the scale
                                carState.trackerPos = trackPos;
                                carState.trackerSector = sector;
                                carState.trackerInPit = inPit;
                                carState.lastTrackerUpdate = Date.now();
                            }
                        }
                    });
                }
            },
            't_l': (args) => {
                console.log('[Tracker Lap]', args);
            },
            't_o': (args) => {
                console.log('[Tracker Out]', args);
            },
            't_c': (args) => {
                console.log('[Tracker Completed]', args);
            },
            't_s': (args) => {
                console.log('[Tracker Stop]', args);
            }
        };
        
        // Process hub messages
        let debugMsgCount = 0;
        
        function updateDebugInfo(method) {
            debugMsgCount++;
            const debugHeaders = document.getElementById('debugHeaders');
            const debugRows = document.getElementById('debugRows');
            const debugMsgCountEl = document.getElementById('debugMsgCount');
            const debugLastMethod = document.getElementById('debugLastMethod');
            
            if (debugHeaders) debugHeaders.textContent = headers.length;
            if (debugRows) debugRows.textContent = rows.length;
            if (debugMsgCountEl) debugMsgCountEl.textContent = debugMsgCount;
            if (debugLastMethod) debugLastMethod.textContent = method;
        }
        
        function processHubMessage(msg) {
            let method, args;
            
            if (Array.isArray(msg)) {
                method = msg[0];
                args = msg.slice(1);
            } else if (msg.M) {
                method = msg.M;
                args = msg.A || [];
            } else {
                console.log('Unknown message format:', msg);
                return;
            }
            
            // Only log non-frequent messages (skip t_p, r_c which are very frequent)
            if (!['t_p', 'r_c', 'h_h'].includes(method)) {
                console.log('[' + method + ']', args);
            }
            updateDebugInfo(method);
            
            // Use handler if exists
            const handler = messageHandlers[method];
            if (handler) {
                handler(args);
            } else {
                console.log('[Unknown method]', method);
            }
        }
        
        // Wrapper functions for legacy compatibility
        function handleHeatState(data) {
            Store.session.lastUpdateRealTime = Date.now();
            updateHeatState(data);
        }
        
        function handleStatistics(data) {
            updateStatistics(data);
        }
        
        function renderResults() {
            updateResults();
        }
        
        function renderMessages() {
            updateMessages();
        }
        
        function processResultsCells(cells) {
            if (!Array.isArray(cells)) return;
            
            const now = Date.now();
            
            cells.forEach(cell => {
                if (!Array.isArray(cell) || cell.length < 3) return;
                const [rowIdx, colIdx, value, meta] = cell;
                
                if (rowIdx === -1 && colIdx === -1) return;
                
                // Ensure row exists (legacy)
                while (rows.length <= rowIdx) {
                    rows.push({ _index: rows.length });
                }
                
                // Always store by column number
                const colKey = 'col_' + colIdx;
                const oldValue = rows[rowIdx][colKey];
                rows[rowIdx][colKey] = value;
                if (meta !== undefined) rows[rowIdx][colKey + '_meta'] = meta;
                
                // Also store by header key if we have headers
                const header = headers[colIdx];
                if (header && header.key) {
                    rows[rowIdx][header.key] = value;
                    if (meta !== undefined) rows[rowIdx][header.key + '_meta'] = meta;
                }
                
                // Get car number and update Store.cars
                const carNum = rows[rowIdx].startnumber || rows[rowIdx].col_2;
                if (carNum) {
                    const car = getCar(carNum);
                    const fieldName = header?.key || colKey;
                    
                    // Sync row data to car
                    car.data[fieldName] = value;
                    if (meta !== undefined) car.meta[fieldName] = meta;
                    car.updatedAt = now;
                    
                    // Update specific car properties
                    if (fieldName === 'position' || fieldName === 'col_0') {
                        car.pos = parseInt(value, 10) || 999;
                    }
                    if (fieldName === 'position_in_class') {
                        car.posInClass = parseInt(value, 10) || null;
                    }
                    if (fieldName === 'state' || fieldName === 'col_3') {
                        car.state = value;
                    }
                    if (fieldName === 'lastroundtime' || fieldName === 'col_13') {
                        const lapTime = parseInt(value, 10);
                        if (!isNaN(lapTime) && lapTime > 0 && lapTime < 999999999999) {
                            car.lastLapTime = lapTime;
                        }
                    }
                    if (fieldName === 'fastestroundtime' || fieldName === 'col_14') {
                        const bestTime = parseInt(value, 10);
                        if (!isNaN(bestTime) && bestTime > 0 && bestTime < 999999999999) {
                            car.bestLapTime = bestTime;
                        }
                    }
                    if (fieldName === 'hole' || fieldName === 'diff' || fieldName === 'col_11' || fieldName === 'col_12') {
                        car.gapToLeader = value;
                    }
                    
                    // Track updates for highlighting
                    const battleFields = ['diff', 'hole', 'gap', 'lastroundtime', 'fastestroundtime', 
                                         'sectortimes_1', 'sectortimes_2', 'sectortimes_3',
                                         'col_11', 'col_12', 'col_13', 'col_14', 'col_16', 'col_17', 'col_18'];
                    
                    if (battleFields.includes(fieldName) && oldValue !== value) {
                        if (!recentUpdates[carNum]) {
                            recentUpdates[carNum] = { timestamp: now, fields: [], changes: {} };
                        }
                        recentUpdates[carNum].timestamp = now;
                        recentUpdates[carNum].changes[fieldName] = { from: oldValue, to: value, time: now };
                        if (!recentUpdates[carNum].fields.includes(fieldName)) {
                            recentUpdates[carNum].fields.push(fieldName);
                        }
                        
                        // Track on car object too
                        if (!car.updatedFields.includes(fieldName)) {
                            car.updatedFields.push(fieldName);
                        }
                    }
                    
                    // Track pending sector times
                    if ((fieldName === 'sectortimes_1' || fieldName === 'col_16') && oldValue !== value) {
                        const sectorVal = parseInt(value, 10);
                        if (!isNaN(sectorVal) && sectorVal > 0 && sectorVal < 999999999999) {
                            car.pendingSectors.s1 = sectorVal;
                            if (!pendingSectors[carNum]) pendingSectors[carNum] = {};
                            pendingSectors[carNum].s1 = sectorVal;
                        }
                    }
                    if ((fieldName === 'sectortimes_2' || fieldName === 'col_17') && oldValue !== value) {
                        const sectorVal = parseInt(value, 10);
                        if (!isNaN(sectorVal) && sectorVal > 0 && sectorVal < 999999999999) {
                            car.pendingSectors.s2 = sectorVal;
                            if (!pendingSectors[carNum]) pendingSectors[carNum] = {};
                            pendingSectors[carNum].s2 = sectorVal;
                        }
                    }
                    if ((fieldName === 'sectortimes_3' || fieldName === 'col_18') && oldValue !== value) {
                        const sectorVal = parseInt(value, 10);
                        if (!isNaN(sectorVal) && sectorVal > 0 && sectorVal < 999999999999) {
                            car.pendingSectors.s3 = sectorVal;
                            addSector3ToLastLap(carNum, sectorVal);
                            if (!pendingSectors[carNum]) pendingSectors[carNum] = {};
                            pendingSectors[carNum].s3 = sectorVal;
                        }
                    }
                    
                    // Record lap time history
                    if ((fieldName === 'lastroundtime' || fieldName === 'col_13') && oldValue !== value) {
                        recordCarLapTime(carNum, value, rows[rowIdx]);
                    }
                    
                    // Detect pit stops
                    if ((fieldName === 'pittime' || fieldName === 'col_20') && oldValue !== value) {
                        detectPitStop(carNum, oldValue, value, rows[rowIdx]);
                    }
                }
            });
        }
        
        // Process bulk initialization data from compressed _ message
        // The decompressed data is an array of init messages: [["method", data], ["method", data], ...]
        function processBulkInit(data) {
            console.log('[processBulkInit] Processing bulk data');
            
            // Data is an array of [method, args] pairs
            if (Array.isArray(data)) {
                data.forEach(msg => {
                    if (Array.isArray(msg) && msg.length >= 2) {
                        const method = msg[0];
                        
                        console.log('[processBulkInit] Processing:', method);
                        
                        // Process each init message
                        switch (method) {
                            case 'h_i':
                                Store.session.lastUpdateRealTime = Date.now();
                                updateHeatState(msg[1]);
                                break;
                                
                            case 'r_i':
                                rows = [];
                                Store.cars.clear();
                                rowCache.clear();
                                
                                if (msg[1]?.l?.h) {
                                    headers = msg[1].l.h.map(h => {
                                        let key = h.n ? h.n.toLowerCase().replace(/\s/g, '_') : '';
                                        if (h.p) key += '_' + h.p;
                                        return { name: h.n || '', caption: h.c || '', key: key };
                                    });
                                    Store.headers = headers;
                                    console.log('[processBulkInit] Headers:', headers.map(h => h.key).join(', '));
                                }
                                if (msg[1]?.r) {
                                    processResultsCells(msg[1].r);
                                    console.log('[processBulkInit] Rows:', rows.length);
                                }
                                break;
                                
                            case 'a_i':
                                updateStatistics(msg[1]);
                                break;
                                
                            case 't_i':
                                console.log('[processBulkInit] Tracker data received:', msg[1]);
                                // Log structure to understand tracker data format
                                if (msg[1]) {
                                    const trackerData = msg[1];
                                    if (trackerData.t) console.log('[Tracker] Track data:', trackerData.t);
                                    if (trackerData.c) console.log('[Tracker] Cars:', trackerData.c);
                                    if (trackerData.p) console.log('[Tracker] Positions:', trackerData.p);
                                }
                                break;
                                
                            case 'm_i':
                                messages = [];
                                Store.messages = [];
                                console.log('[processBulkInit] Messages data:', msg[1]);
                                if (Array.isArray(msg[1])) {
                                    console.log('[processBulkInit] Messages count:', msg[1].length);
                                    if (msg[1].length > 0) {
                                        console.log('[processBulkInit] First message sample:', msg[1][0]);
                                    }
                                    msg[1].forEach(m => {
                                        const parsed = { id: m.Id, t: m.t, bc: intToRgb(m.bc), fc: intToRgb(m.fc) };
                                        messages.push(parsed);
                                        Store.messages.push(parsed);
                                    });
                                }
                                break;
                        }
                    }
                });
                
                // Batch render all updates
                requestRender(renderResults);
                requestRender(renderMessages);
            }
        }
        
        // UI Update functions
        function updateHeatState(data) {
            if (!data) return;
            
            if (data.n) {
                el.raceName.textContent = data.n;
                heatState.name = data.n;
            }
            
            if (data.f !== undefined) {
                el.flagIndicator.className = 'flag-indicator ' + (flagClasses[String(data.f)] || 'not-started');
                el.flagText.textContent = flagTexts[String(data.f)] || 'UNKNOWN';
                heatState.flag = data.f;
            }
            
            // ll = leader laps completed
            if (data.ll !== undefined) {
                el.currentLap.textContent = data.ll;
                heatState.leaderLap = parseInt(data.ll, 10) || 0;
            }
            
            // q = current time (microseconds since Jan 1, 2000)
            if (data.q !== undefined) {
                currentSessionTime = data.q;
                heatState.currentTime = data.q;
            }
            
            // s = start time (microseconds since Jan 1, 2000)
            if (data.s !== undefined) {
                heatState.startTime = data.s;
            }
            
            // e = end time (expected finish time)
            if (data.e !== undefined) {
                heatState.endTime = data.e;
            }
            
            // r = race time elapsed (sent in periodic h_h updates)
            if (data.r !== undefined && data.r > 0) {
                heatState.raceTimeElapsed = data.r;
                // Use this directly as elapsed time if valid
                if (data.r > 1000000 && data.r < 999999999999) {
                    heatState.elapsedTime = data.r;
                    el.clockTime.textContent = formatRaceTime(data.r);
                }
            }
            
            // lt = TimeLength (race duration in microseconds)
            if (data.lt !== undefined) {
                heatState.timeLength = data.lt;
            }
            
            // lr = LapsLength (total laps in race)
            if (data.lr !== undefined) {
                heatState.lapsLength = parseInt(data.lr, 10) || 0;
            }
            
            // lm = LengthMode (0 = TimeANDRounds, 1 = TimeOrRounds)
            if (data.lm !== undefined) {
                heatState.lengthMode = data.lm;
            }
            
            // chd or similar = clock halted duration
            if (data.chd !== undefined) {
                heatState.clockHaltedDuration = data.chd;
            }
            
            // Calculate elapsed from start/current time if not available via 'r'
            if (!heatState.elapsedTime && heatState.startTime && heatState.currentTime) {
                const elapsed = heatState.currentTime - heatState.startTime - (heatState.clockHaltedDuration || 0);
                if (elapsed > 0) {
                    el.clockTime.textContent = formatRaceTime(elapsed);
                    heatState.elapsedTime = elapsed;
                }
            }
            
            // Calculate time to go and ETA
            updateRaceProgress();
        }
        
        // Update race progress display (time to go, ETA, laps)
        let lastRaceProgressLog = 0;
        function updateRaceProgress() {
            // Debug current state (throttled to every 10 seconds)
            const now = Date.now();
            const shouldLog = (now - lastRaceProgressLog) > 10000;
            if (shouldLog) {
                lastRaceProgressLog = now;
                console.log('[RaceProgress] timeLength:', heatState.timeLength, 'endTime:', heatState.endTime, 'elapsed:', heatState.elapsedTime, 'lapsLength:', heatState.lapsLength, 'leaderLap:', heatState.leaderLap);
            }
            
            let timeToGoMicroseconds = null;
            
            // Method 1: Time-based race using timeLength
            if (heatState.timeLength && heatState.timeLength > 0 && heatState.elapsedTime) {
                timeToGoMicroseconds = heatState.timeLength - heatState.elapsedTime;
                if (shouldLog) console.log('[RaceProgress] Method 1 (timeLength): remaining =', formatRaceTime(Math.max(0, timeToGoMicroseconds)));
            }
            // Method 2: Use endTime - currentTime
            else if (heatState.endTime && heatState.currentTime && heatState.endTime > heatState.currentTime) {
                timeToGoMicroseconds = heatState.endTime - heatState.currentTime;
                if (shouldLog) console.log('[RaceProgress] Method 2 (endTime): remaining =', formatRaceTime(Math.max(0, timeToGoMicroseconds)));
            }
            // Method 3: Lap-based race - estimate from average lap time
            else if (heatState.lapsLength && heatState.lapsLength > 0 && heatState.leaderLap > 0 && heatState.elapsedTime > 0) {
                const lapsRemaining = heatState.lapsLength - heatState.leaderLap;
                if (lapsRemaining > 0) {
                    const avgLapTime = heatState.elapsedTime / heatState.leaderLap;
                    timeToGoMicroseconds = avgLapTime * lapsRemaining;
                    if (shouldLog) console.log('[RaceProgress] Method 3 (laps): lapsRemaining =', lapsRemaining, ', avgLap =', formatRaceTime(avgLapTime), ', remaining ~', formatRaceTime(timeToGoMicroseconds));
                }
            }
            
            // Display time to go and ETA
            if (timeToGoMicroseconds !== null) {
                el.timeToGoContainer.style.display = 'block';
                
                if (timeToGoMicroseconds > 0) {
                    // Show "~" prefix for estimated (lap-based) calculation
                    const prefix = (!heatState.timeLength && !heatState.endTime) ? '~' : '';
                    el.timeToGo.textContent = prefix + formatRaceTime(timeToGoMicroseconds);
                    
                    // Color: red if < 10 minutes (or < 5 laps for lap-based)
                    const isUrgent = timeToGoMicroseconds < 600000000 || 
                                    (heatState.lapsLength && (heatState.lapsLength - heatState.leaderLap) <= 5);
                    el.timeToGo.style.color = isUrgent ? 'var(--accent-red)' : 'var(--accent-yellow)';
                    
                    // Calculate ETA: current real time + time remaining
                    // timeToGoMicroseconds is in microseconds, need to convert to milliseconds
                    const timeToGoMs = timeToGoMicroseconds / 1000;
                    const etaTimestamp = Date.now() + timeToGoMs;
                    const etaDate = new Date(etaTimestamp);
                    
                    el.etaContainer.style.display = 'block';
                    el.etaTime.textContent = etaDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    
                    if (shouldLog) console.log('[RaceProgress] ETA:', etaDate.toLocaleTimeString(), '(in', Math.round(timeToGoMs / 60000), 'minutes)');
                } else {
                    el.timeToGo.textContent = heatState.lapsLength ? 'FINAL LAP' : 'FINISHED';
                    el.timeToGo.style.color = 'var(--accent-green)';
                    el.etaContainer.style.display = 'none';
                }
            } else {
                // No time info available - hide containers
                el.timeToGoContainer.style.display = 'none';
                el.etaContainer.style.display = 'none';
            }
            
            // Display total laps if available
            if (heatState.lapsLength && heatState.lapsLength > 0) {
                el.totalLaps.textContent = '/' + heatState.lapsLength;
            } else {
                el.totalLaps.textContent = '';
            }
        }
        
        // Calculate ETA for a car based on race end and gap
        function calculateCarETA(carData) {
            // Get base race end time (microseconds since Jan 1, 2000)
            let raceEndMicroseconds = null;
            
            // Method 1: Use endTime directly
            if (heatState.endTime) {
                raceEndMicroseconds = heatState.endTime;
            }
            // Method 2: Calculate from timeLength
            else if (heatState.timeLength && heatState.startTime) {
                raceEndMicroseconds = heatState.startTime + heatState.timeLength;
            }
            // Method 3: Estimate from laps
            else if (heatState.lapsLength && heatState.leaderLap > 0 && heatState.elapsedTime && heatState.currentTime) {
                const lapsRemaining = heatState.lapsLength - heatState.leaderLap;
                const avgLapTime = heatState.elapsedTime / heatState.leaderLap;
                const timeToFinish = avgLapTime * lapsRemaining;
                raceEndMicroseconds = heatState.currentTime + timeToFinish;
            }
            
            if (!raceEndMicroseconds) return '-';
            
            // Convert protocol time (microseconds since Jan 1, 2000) to JS Date
            // Jan 1, 2000 00:00:00 UTC in milliseconds since epoch
            const jan2000 = Date.UTC(2000, 0, 1);
            
            // Get car's position
            const pos = parseInt(carData.position || carData.col_0 || '999', 10);
            
            // Leader finishes at race end
            if (pos === 1) {
                const etaMs = jan2000 + (raceEndMicroseconds / 1000);
                const etaDate = new Date(etaMs);
                return etaDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            
            // Other cars: check their gap
            const gap = carData.hole || carData.gap || carData.col_11 || '';
            const gapStr = String(gap).trim();
            
            // Check if lapped (-- XX laps -- format)
            const lappedMatch = gapStr.match(/--\s*(\d+)\s*laps?\s*--/i);
            if (lappedMatch) {
                // Lapped cars finish when leader finishes (get checkered flag)
                const etaMs = jan2000 + (raceEndMicroseconds / 1000);
                const etaDate = new Date(etaMs);
                return etaDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + '*';
            }
            
            // Time gap: parse and add to race end
            let gapMicroseconds = 0;
            
            // Format: "1:23.456" or "23.456" or just seconds
            const timeMatch = gapStr.match(/^(\d+):(\d+\.?\d*)$/);
            if (timeMatch) {
                // Minutes:Seconds.ms format
                const mins = parseInt(timeMatch[1], 10);
                const secs = parseFloat(timeMatch[2]);
                gapMicroseconds = (mins * 60 + secs) * 1000000;
            } else {
                // Just seconds
                const secs = parseFloat(gapStr);
                if (!isNaN(secs)) {
                    gapMicroseconds = secs * 1000000;
                }
            }
            
            // Calculate ETA: race end + gap
            const carFinishMicroseconds = raceEndMicroseconds + gapMicroseconds;
            const etaMs = jan2000 + (carFinishMicroseconds / 1000);
            const etaDate = new Date(etaMs);
            
            return etaDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function updateResults() {
            if (headers.length === 0) {
                el.resultsHead.innerHTML = '<tr><th>Waiting for data...</th></tr>';
                el.resultsBody.innerHTML = '<tr><td class="loading"><div class="spinner"></div><div>Connect to see results</div></td></tr>';
                return;
            }
            
            // Find which columns actually have data
            const usedColumns = new Set();
            rows.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (!key.endsWith('_meta') && key !== '_index' && !key.startsWith('col_') && row[key] !== undefined && row[key] !== '') {
                        usedColumns.add(key);
                    }
                });
            });
            
            // Build headers - include default headers that have data, but NOT generic col_N headers
            let displayHeaders = headers.filter(h => usedColumns.has(h.key) && !h.key.startsWith('col_'));
            
            // Sort by original order
            displayHeaders.sort((a, b) => {
                const aIdx = headers.findIndex(h => h.key === a.key);
                const bIdx = headers.findIndex(h => h.key === b.key);
                if (aIdx >= 0 && bIdx >= 0) return aIdx - bIdx;
                return 0;
            });
            
            // Add ETA column if we have race end time info
            const showETA = (heatState.timeLength && heatState.elapsedTime) || heatState.endTime;
            if (showETA) {
                displayHeaders.push({ key: '_eta', caption: 'ETA', name: 'ETA' });
            }
            
            // If still no display headers, use all headers
            if (displayHeaders.length === 0 && headers.length > 0) {
                displayHeaders = headers.filter(h => !h.key.startsWith('col_'));
            }
            
            if (displayHeaders.length === 0) {
                el.resultsBody.innerHTML = '<tr><td>No data yet</td></tr>';
                return;
            }
            
            // Update headers
            el.resultsHead.innerHTML = '<tr>' + displayHeaders.map(h => 
                `<th class="${['position', 'startnumber', 'laps', 'pitstops'].includes(h.key) ? 'center' : 
                              ['lastroundtime', 'fastestroundtime', 'gap', 'diff'].includes(h.key) ? 'right' : ''}">${h.caption || h.name}</th>`
            ).join('') + '</tr>';
            
            if (rows.length === 0) {
                el.resultsBody.innerHTML = '<tr><td colspan="' + displayHeaders.length + '" class="loading"><div class="spinner"></div><div>Waiting for data...</div></td></tr>';
                return;
            }
            
            // Sort rows by position
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            el.participantCount.textContent = sortedRows.length + ' Participants';
            
            el.resultsBody.innerHTML = sortedRows.map(row => {
                const carNum = row.startnumber || row.col_2 || '';
                const isTracked = carNum === trackedCarNumber;
                const rowStyle = isTracked ? 'background: rgba(0, 255, 136, 0.12) !important; border-left: 3px solid var(--accent-green);' : '';
                return `<tr style="${rowStyle}" onclick="trackCar('${carNum}')" ondblclick="openCarAnalysis('${carNum}')" class="clickable-row" title="Click to track, double-click to analyze">` + displayHeaders.map(h => {
                    let value = row[h.key];
                    if (value === undefined || value === null) value = '';
                    
                    // Filter out max int64 value (used as "no value" placeholder)
                    if (value === '9223372036854775807' || value === 9223372036854775807) value = '';
                    
                    let className = '';
                    let style = '';
                    const meta = row[h.key + '_meta'];
                    
                    if (h.key === 'position') {
                        className = 'position' + (parseInt(value) <= 3 ? ' p' + value : '');
                    } else if (h.key === 'startnumber') {
                        if (value) value = `<span class="car-number">${value}</span>`;
                        className = 'center';
                    } else if (['lastroundtime', 'fastestroundtime'].includes(h.key)) {
                        const rawVal = parseInt(value, 10);
                        if (!isNaN(rawVal) && rawVal > 1000000 && rawVal < 999999999999) {
                            value = formatTime(rawVal);
                        }
                        className = 'right lap-time';
                        // Check for best lap indicator
                        if (meta === '65280' || meta === 65280) className += ' personal-best';
                        else if (meta === '16736511' || meta === 16736511) className += ' best';
                    } else if (h.key === 'hole' || h.key === 'gap') {
                        className = 'right gap-time';
                    } else if (h.key === 'diff' || h.key === 'interval') {
                        className = 'right interval-time';
                    } else if (['laps', 'pitstops', 'fastestroundnumber'].includes(h.key)) {
                        className = 'center';
                        style = 'font-family: "Roboto Mono", monospace; font-weight: 600;';
                    } else if (h.key === 'class' || h.key === 'position_in_class') {
                        // Class colors - meta is hex like "000080FFFFFF" (bg + fg)
                        if (meta && typeof meta === 'string' && meta.length === 12) {
                            const bgHex = meta.substring(0, 6);
                            const fgHex = meta.substring(6, 12);
                            const bg = `#${bgHex}`;
                            const fg = `#${fgHex}`;
                            style = `background-color: ${bg}; color: ${fg}; padding: 4px 8px; border-radius: 4px; font-weight: 600;`;
                        }
                        className = 'center';
                    } else if (h.key.startsWith('sectortimes')) {
                        // Sector times (sectortimes_1, sectortimes_2, sectortimes_3)
                        const rawVal = parseInt(value, 10);
                        if (!isNaN(rawVal) && rawVal > 1000000 && rawVal < 999999999999) {
                            value = formatSectorTime(rawVal);
                        }
                        className = 'right lap-time';
                        if (meta === '65280' || meta === 65280) className += ' personal-best';
                        else if (meta === '16736511' || meta === 16736511) className += ' best';
                    } else if (['pittime', 'currentdriverstinttime'].includes(h.key)) {
                        // Pit time and stint time - may be a start timestamp (S prefix) or duration
                        value = formatStintTime(value);
                        className = 'right';
                        style = 'font-family: "Roboto Mono", monospace;';
                    } else if (h.key === 'marker' || h.key === 'sectionmarker') {
                        className = 'center';
                    } else if (h.key === '_eta') {
                        // Calculate ETA for this car
                        value = calculateCarETA(row);
                        className = 'center';
                        style = 'color: var(--accent-cyan); font-family: "Roboto Mono", monospace; font-weight: 600; font-size: 14px;';
                    } else if (h.key === 'name' || h.key === 'currentdriver') {
                        className = 'driver-name';
                    } else if (h.key === 'car' || h.key === 'team') {
                        className = 'team-name';
                    }
                    
                    const styleAttr = style ? ` style="${style}"` : '';
                    return `<td class="${className}"${styleAttr}>${value}</td>`;
                }).join('') + '</tr>';
            }).join('');
            
            // Update battle tracker if a car is being tracked
            if (trackedCarNumber) {
                updateBattleTracker();
            }
            
            // Update all battles view if that tab is active
            if (currentBattleTab === 'all') {
                updateAllBattles();
            }
            
            // Update fullscreen battle view if open
            if (!document.getElementById('battleModal').classList.contains('hidden')) {
                updateFullscreenBattles();
            }
            
            // Update track fullscreen view if open
            if (!document.getElementById('trackFullscreenModal').classList.contains('hidden')) {
                updateTrackFullscreen();
            }
            
            // Update car analysis modal if open
            if (!document.getElementById('carAnalysisModal').classList.contains('hidden')) {
                setAnalysisTab(currentAnalysisTab);
            }
            
            // Update position graph
            updatePositionGraph();
        }
        
        function updateStatistics(data) {
            if (!data) return;
            
            // a_i/a_u format has different field names
            if (data.pt !== undefined) el.statOnTrack.textContent = data.pt;
            if (data.pp !== undefined) el.statInPit.textContent = data.pp;
            if (data.o !== undefined) el.statTotalLaps.textContent = data.o;
            if (data.x !== undefined) el.statPitStops.textContent = data.x;
            
            // Also update participants count if available
            if (data.p !== undefined) {
                el.participantCount.textContent = data.p + ' Participants';
            }
        }
        
        function updateMessages() {
            if (messages.length === 0) {
                el.messagesContainer.innerHTML = '<div class="message-item" style="background: rgba(100, 100, 100, 0.3); color: #fff;">No messages</div>';
                return;
            }
            
            el.messagesContainer.innerHTML = messages.slice(-10).reverse().map(m => 
                `<div class="message-item" style="background: rgb(${m.bc || '100,100,100'}); color: #ffffff;">${m.t || ''}</div>`
            ).join('');
        }
        
        // Battle Tracker Functions
        function setTrackedCar() {
            const input = document.getElementById('trackCarInput');
            const carNum = input.value.trim();
            if (carNum) {
                trackCar(carNum);
            }
        }
        
        function trackCar(carNum, switchToTrack = false) {
            trackedCarNumber = carNum;
            Store.ui.trackedCarNumber = carNum;
            document.getElementById('trackCarInput').value = carNum;
            gapHistory[carNum] = gapHistory[carNum] || { ahead: [], behind: [] };
            updateBattleTracker();
            requestRender(renderResults); // Re-render to highlight tracked car
            
            // Switch to track tab if requested (from all battles view)
            if (switchToTrack) {
                switchBattleTab('track');
            }
        }
        
        // Tab switching
        let currentBattleTab = 'track';
        
        function switchBattleTab(tab) {
            currentBattleTab = tab;
            const trackTab = document.getElementById('trackCarTab');
            const allTab = document.getElementById('allBattlesTab');
            const trackBtn = document.getElementById('tabTrackCar');
            const allBtn = document.getElementById('tabAllBattles');
            
            if (tab === 'track') {
                trackTab.style.display = 'block';
                allTab.style.display = 'none';
                trackBtn.style.color = 'var(--text-primary)';
                trackBtn.style.borderBottom = '2px solid var(--accent-green)';
                allBtn.style.color = 'var(--text-muted)';
                allBtn.style.borderBottom = '2px solid transparent';
            } else {
                trackTab.style.display = 'none';
                allTab.style.display = 'block';
                trackBtn.style.color = 'var(--text-muted)';
                trackBtn.style.borderBottom = '2px solid transparent';
                allBtn.style.color = 'var(--text-primary)';
                allBtn.style.borderBottom = '2px solid var(--accent-red)';
                updateAllBattles();
            }
        }
        
        // All battles view
        function updateAllBattles() {
            const container = document.getElementById('allBattlesContainer');
            if (rows.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">Waiting for data...</div>';
                return;
            }
            
            const threshold = parseFloat(document.getElementById('battleThreshold').value);
            
            // Sort rows by position
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            let html = '';
            let battlesFound = 0;
            
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                const pos = car.position || car.col_0 || '?';
                const name = car.name || car.col_4 || '';
                const driver = car.currentdriver || car.col_7 || '';
                const carClass = car.class || car.col_9 || '';
                const gapAhead = car.diff || car.col_12 || '';
                
                // Parse gap
                const gapSeconds = parseGapToSeconds(gapAhead);
                
                // Get trend if we have history
                let trendHtml = '';
                if (gapHistory[carNum] && gapHistory[carNum].ahead) {
                    const trend = formatGapTrend(gapSeconds, gapHistory[carNum].ahead);
                    if (trend.trend === 'gaining') {
                        trendHtml = `<span style="color: var(--accent-green); font-size: 10px;">‚ñ≤${trend.diff.toFixed(2)}s</span>`;
                    } else if (trend.trend === 'losing') {
                        trendHtml = `<span style="color: var(--accent-red); font-size: 10px;">‚ñº${trend.diff.toFixed(2)}s</span>`;
                    }
                }
                
                // Update gap history for all cars
                if (!gapHistory[carNum]) {
                    gapHistory[carNum] = { ahead: [], behind: [] };
                }
                if (gapSeconds !== null) {
                    pushCapped(gapHistory[carNum].ahead, gapSeconds, GAP_HISTORY_SIZE);
                }
                
                // Check if this is a battle (gap < threshold)
                const isBattle = gapSeconds !== null && gapSeconds < threshold && index > 0;
                const isBeingCaught = gapHistory[carNum]?.ahead?.length > 3 && 
                    formatGapTrend(gapSeconds, gapHistory[carNum].ahead).trend === 'gaining';
                
                // Skip if threshold is set and not a battle (unless showing all)
                if (threshold < 100 && !isBattle && index > 0) return;
                
                battlesFound++;
                
                // Determine battle status
                let statusIcon = '';
                let statusColor = 'var(--text-muted)';
                let borderColor = 'var(--border-color)';
                
                if (index === 0) {
                    statusIcon = 'üëë';
                    statusColor = 'var(--accent-yellow)';
                    borderColor = 'var(--accent-yellow)';
                } else if (gapSeconds !== null && gapSeconds < 1) {
                    statusIcon = 'üî•';
                    statusColor = 'var(--accent-red)';
                    borderColor = 'var(--accent-red)';
                } else if (gapSeconds !== null && gapSeconds < 2) {
                    statusIcon = '‚öîÔ∏è';
                    statusColor = 'var(--accent-yellow)';
                    borderColor = 'var(--accent-yellow)';
                } else if (gapSeconds !== null && gapSeconds < 5) {
                    statusIcon = 'üëÄ';
                    statusColor = 'var(--text-secondary)';
                    borderColor = 'var(--text-muted)';
                }
                
                const carAhead = index > 0 ? sortedRows[index - 1] : null;
                const carAheadNum = carAhead ? (carAhead.startnumber || carAhead.col_2 || '?') : '';
                
                html += `
                    <div onclick="trackCar('${carNum}', true)" style="background: var(--bg-tertiary); padding: 8px 10px; border-radius: 6px; margin-bottom: 6px; cursor: pointer; border-left: 3px solid ${borderColor}; transition: all 0.2s;" onmouseover="this.style.background='var(--bg-row-hover)'" onmouseout="this.style.background='var(--bg-tertiary)'">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 14px;">${statusIcon}</span>
                                <span style="font-family: 'Orbitron'; font-weight: bold; font-size: 12px; color: ${statusColor};">P${pos}</span>
                                <span style="background: var(--accent-red); color: #fff; padding: 2px 6px; border-radius: 3px; font-family: 'Orbitron'; font-size: 11px; font-weight: bold;">#${carNum}</span>
                            </div>
                            <div style="text-align: right;">
                                ${index > 0 ? `
                                    <div style="font-family: 'Roboto Mono'; font-size: 12px; font-weight: bold;">${gapAhead || '-'}</div>
                                    <div style="font-size: 10px; color: var(--text-muted);">to #${carAheadNum}</div>
                                ` : `<span style="font-size: 11px; color: var(--accent-yellow);">LEADER</span>`}
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
                            <div style="font-size: 11px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${name}</div>
                            ${trendHtml}
                        </div>
                    </div>
                `;
            });
            
            if (battlesFound === 0) {
                html = '<div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">No battles within threshold</div>';
            } else {
                html = `<div style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px; text-align: center;">${battlesFound} cars shown ‚Ä¢ Click to track</div>` + html;
            }
            
            container.innerHTML = html;
        }
        
        function parseGapToSeconds(gapStr) {
            if (!gapStr || gapStr === '' || gapStr.startsWith('--')) return null;
            
            // Handle "X laps" format
            if (gapStr.includes('lap')) {
                const match = gapStr.match(/(\d+)\s*lap/);
                return match ? parseInt(match[1]) * 100 : null; // Use 100s per lap as approximation
            }
            
            // Handle "M:SS.mmm" format
            if (gapStr.includes(':')) {
                const parts = gapStr.split(':');
                return parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
            }
            
            // Handle "SS.mmm" format
            return parseFloat(gapStr);
        }
        
        function formatGapTrend(currentGap, history) {
            if (history.length < 2 || currentGap === null) return { trend: 'stable', diff: 0 };
            
            // Compare to reading from ~5 updates ago
            const oldReading = history[Math.max(0, history.length - 5)];
            if (oldReading === null || oldReading === undefined) return { trend: 'stable', diff: 0 };
            
            const diff = currentGap - oldReading;
            
            if (Math.abs(diff) < 0.05) return { trend: 'stable', diff: 0 };
            if (diff > 0) return { trend: 'losing', diff: diff };
            return { trend: 'gaining', diff: Math.abs(diff) };
        }
        
        function updateBattleTracker() {
            const container = document.getElementById('battleTracker');
            if (!trackedCarNumber || rows.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">Enter a car number to track</div>';
                return;
            }
            
            // Sort rows by position
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            // Find tracked car
            const trackedIndex = sortedRows.findIndex(r => 
                (r.startnumber || r.col_2) === trackedCarNumber
            );
            
            if (trackedIndex === -1) {
                container.innerHTML = `<div style="color: var(--accent-red); font-size: 12px; text-align: center; padding: 20px;">Car #${trackedCarNumber} not found</div>`;
                return;
            }
            
            const trackedCar = sortedRows[trackedIndex];
            const carAhead = trackedIndex > 0 ? sortedRows[trackedIndex - 1] : null;
            const carBehind = trackedIndex < sortedRows.length - 1 ? sortedRows[trackedIndex + 1] : null;
            
            // Get gaps
            const gapToAhead = trackedCar.diff || trackedCar.col_12 || '';
            const gapFromBehind = carBehind ? (carBehind.diff || carBehind.col_12 || '') : '';
            
            // Parse gaps for history
            const gapAheadSeconds = parseGapToSeconds(gapToAhead);
            const gapBehindSeconds = parseGapToSeconds(gapFromBehind);
            
            // Initialize history for this car
            if (!gapHistory[trackedCarNumber]) {
                gapHistory[trackedCarNumber] = { ahead: [], behind: [] };
            }
            
            // Also track on Store.cars
            const trackedCarStore = getCar(trackedCarNumber);
            
            // Add to history using pushCapped
            if (gapAheadSeconds !== null) {
                pushCapped(gapHistory[trackedCarNumber].ahead, gapAheadSeconds, GAP_HISTORY_SIZE);
                pushCapped(trackedCarStore.history.gaps, { timestamp: Date.now(), ahead: gapAheadSeconds, behind: gapBehindSeconds }, GAP_HISTORY_SIZE);
            }
            if (gapBehindSeconds !== null) {
                pushCapped(gapHistory[trackedCarNumber].behind, gapBehindSeconds, GAP_HISTORY_SIZE);
            }
            
            // Calculate trends
            const aheadTrend = formatGapTrend(gapAheadSeconds, gapHistory[trackedCarNumber].ahead);
            const behindTrend = formatGapTrend(gapBehindSeconds, gapHistory[trackedCarNumber].behind);
            
            // Build HTML
            const getTrendIcon = (trend, isAhead) => {
                // For car ahead: gaining = closing gap = good (green), losing = falling back = bad (red)
                // For car behind: gaining = they're closing = bad (red), losing = pulling away = good (green)
                if (isAhead) {
                    if (trend.trend === 'gaining') {
                        return `<span style="color: var(--accent-green);">‚ñ≤ CATCHING -${trend.diff.toFixed(2)}s</span>`;
                    } else if (trend.trend === 'losing') {
                        return `<span style="color: var(--accent-red);">‚ñº LOSING +${trend.diff.toFixed(2)}s</span>`;
                    }
                } else {
                    // Behind car - invert the logic
                    if (trend.trend === 'gaining') {
                        return `<span style="color: var(--accent-red);">‚ö† CATCHING -${trend.diff.toFixed(2)}s</span>`;
                    } else if (trend.trend === 'losing') {
                        return `<span style="color: var(--accent-green);">‚úì SAFE +${trend.diff.toFixed(2)}s</span>`;
                    }
                }
                return `<span style="color: var(--text-muted);">‚óè STABLE</span>`;
            };
            
            const getCarName = (car) => {
                if (!car) return null;
                return car.name || car.col_4 || 'Unknown';
            };
            
            const getCarNumber = (car) => {
                if (!car) return null;
                return car.startnumber || car.col_2 || '?';
            };
            
            const getCarClass = (car) => {
                if (!car) return '';
                return car.class || car.col_9 || '';
            };
            
            const getCarDriver = (car) => {
                if (!car) return '';
                return car.currentdriver || car.col_7 || '';
            };
            
            const trackedPos = trackedCar.position || trackedCar.col_0;
            
            let html = `
                <div style="display: flex; flex-direction: column; gap: 8px;">
            `;
            
            // Car Ahead
            if (carAhead) {
                html += `
                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; border-left: 3px solid var(--text-muted);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 11px; color: var(--text-muted);">P${parseInt(trackedPos) - 1} ‚Ä¢ AHEAD</span>
                            <span style="font-family: 'Orbitron'; font-weight: bold; color: var(--accent-yellow);">#${getCarNumber(carAhead)}</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">${getCarName(carAhead)}</div>
                        <div style="font-size: 11px; color: var(--text-muted);">${getCarDriver(carAhead)}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                            <span style="font-size: 11px; color: var(--text-muted);">GAP</span>
                            <span style="font-family: 'Roboto Mono'; font-size: 14px; font-weight: bold;">${gapToAhead || '-'}</span>
                            ${getTrendIcon(aheadTrend, true)}
                        </div>
                    </div>
                `;
            }
            
            // Tracked Car (highlighted)
            html += `
                <div style="background: linear-gradient(135deg, var(--accent-green)22, var(--accent-green)11); padding: 12px; border-radius: 6px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="font-size: 11px; color: var(--accent-green); font-weight: bold;">P${trackedPos} ‚Ä¢ TRACKING</span>
                        <span style="font-family: 'Orbitron'; font-weight: bold; font-size: 18px; color: var(--accent-green);">#${getCarNumber(trackedCar)}</span>
                    </div>
                    <div style="font-size: 13px; color: var(--text-primary); font-weight: 600; margin-bottom: 4px;">${getCarName(trackedCar)}</div>
                    <div style="font-size: 11px; color: var(--text-secondary);">${getCarDriver(trackedCar)} ‚Ä¢ ${getCarClass(trackedCar)}</div>
                    <button onclick="openCarAnalysis('${getCarNumber(trackedCar)}')" style="width: 100%; margin-top: 10px; padding: 8px; background: var(--accent-blue); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-family: 'Orbitron', sans-serif;">üìä ANALYZE CAR</button>
                    <button onclick="openStintAnalysis('${getCarNumber(trackedCar)}')" style="width: 100%; margin-top: 6px; padding: 8px; background: var(--accent-purple); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-family: 'Orbitron', sans-serif;">‚è±Ô∏è STINT ANALYSIS</button>
                </div>
            `;
            
            // Car Behind
            if (carBehind) {
                html += `
                    <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; border-left: 3px solid var(--text-muted);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 11px; color: var(--text-muted);">P${parseInt(trackedPos) + 1} ‚Ä¢ BEHIND</span>
                            <span style="font-family: 'Orbitron'; font-weight: bold; color: var(--accent-yellow);">#${getCarNumber(carBehind)}</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">${getCarName(carBehind)}</div>
                        <div style="font-size: 11px; color: var(--text-muted);">${getCarDriver(carBehind)}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                            <span style="font-size: 11px; color: var(--text-muted);">GAP</span>
                            <span style="font-family: 'Roboto Mono'; font-size: 14px; font-weight: bold;">${gapFromBehind || '-'}</span>
                            ${getTrendIcon(behindTrend, false)}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Fullscreen Battle View
        function openFullscreenBattles() {
            document.getElementById('battleModal').classList.remove('hidden');
            document.getElementById('battleModalRaceName').textContent = heatState.name || '';
            updateFullscreenBattles();
        }
        
        function closeFullscreenBattles() {
            document.getElementById('battleModal').classList.add('hidden');
        }
        
        // Check if a car was recently updated (has pending highlight)
        function isRecentlyUpdated(carNum) {
            return !!recentUpdates[carNum] && recentUpdates[carNum].fields.length > 0;
        }
        
        // Get time since last update for display
        function getUpdateAge(carNum) {
            const update = recentUpdates[carNum];
            if (!update) return null;
            const elapsed = Date.now() - update.timestamp;
            return Math.floor(elapsed / 1000);
        }
        
        // Get the changes for a car
        function getCarChanges(carNum) {
            return recentUpdates[carNum]?.changes || {};
        }
        
        // Clear update highlight for a car when it gets a new update
        function clearUpdateHighlight(carNum) {
            if (recentUpdates[carNum]) {
                recentUpdates[carNum].fields = [];
                recentUpdates[carNum].changes = {};
            }
        }
        
        function updateFullscreenBattles() {
            const cardsContainer = document.getElementById('battleCardsContainer');
            const groupBy = document.getElementById('battleModalGroupBy').value;
            
            if (rows.length === 0) {
                cardsContainer.innerHTML = '<div style="color: var(--text-muted); text-align: center; padding: 40px;">Waiting for data...</div>';
                return;
            }
            
            // Sort rows by position
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            let html = '';
            
            if (groupBy === 'battles') {
                // Show only hot battles
                html = renderBattleGroups(sortedRows);
            } else if (groupBy === 'class') {
                // Group by class
                html = renderByClass(sortedRows);
            } else {
                // Show all by position (grid view)
                html = renderPositionGrid(sortedRows);
            }
            
            cardsContainer.innerHTML = html;
        }
        
        // Clear graph filter
        function clearGraphFilter() {
            document.getElementById('graphCarFilter').value = '';
            updatePositionGraph();
        }
        
        // Set graph view mode (linear, circular, or lapchart)
        function setGraphView(mode) {
            graphViewMode = mode;
            
            // Update buttons
            const btnLinear = document.getElementById('btnLinearView');
            const btnCircular = document.getElementById('btnCircularView');
            const btnLapChart = document.getElementById('btnLapChartView');
            const graphLinear = document.getElementById('positionGraphLinear');
            const graphCircular = document.getElementById('positionGraphCircular');
            const graphLapChart = document.getElementById('positionGraphLapChart');
            
            // Reset all buttons
            [btnLinear, btnCircular, btnLapChart].forEach(btn => {
                if (btn) {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                }
            });
            
            // Hide all graphs
            if (graphLinear) graphLinear.style.display = 'none';
            if (graphCircular) graphCircular.style.display = 'none';
            if (graphLapChart) graphLapChart.style.display = 'none';
            
            // Show selected
            if (mode === 'linear' && btnLinear && graphLinear) {
                btnLinear.style.background = 'var(--accent-green)';
                btnLinear.style.color = '#000';
                graphLinear.style.display = 'block';
            } else if (mode === 'circular' && btnCircular && graphCircular) {
                btnCircular.style.background = 'var(--accent-green)';
                btnCircular.style.color = '#000';
                graphCircular.style.display = 'block';
            } else if (mode === 'lapchart' && btnLapChart && graphLapChart) {
                btnLapChart.style.background = 'var(--accent-green)';
                btnLapChart.style.color = '#000';
                graphLapChart.style.display = 'block';
            }
            
            updatePositionGraph();
        }
        
        // Track fullscreen functions
        function openTrackFullscreen() {
            document.getElementById('trackFullscreenModal').classList.remove('hidden');
            document.getElementById('trackModalRaceName').textContent = heatState.name || '';
            // Sync filter from main graph
            document.getElementById('trackModalFilter').value = document.getElementById('graphCarFilter').value;
            updateTrackFullscreen();
            // Start real-time animation
            startTrackAnimation();
        }
        
        function closeTrackFullscreen() {
            document.getElementById('trackFullscreenModal').classList.add('hidden');
            // Stop animation when modal is closed
            stopTrackAnimation();
        }
        
        // ==================== CAR ANALYSIS FUNCTIONS ====================
        
        // Initialize car history if not exists (synced with Store.cars)
        function initCarHistory(carNum) {
            // Ensure Store.cars entry exists
            const car = getCar(carNum);
            
            // Legacy carHistory for backward compatibility
            if (!carHistory[carNum]) {
                carHistory[carNum] = {
                    lapTimes: [],      // { lap, time, s1, s2, s3, timestamp }
                    pitStops: [],      // { lap, timestamp, duration }
                    positions: [],     // { lap, pos }
                    bestLap: null,
                    totalPits: 0
                };
            }
            return carHistory[carNum];
        }
        
        // Calculate actual lap number from leader lap and gap
        function calculateActualLap(carData) {
            const leaderLap = heatState.leaderLap || Store.session.leaderLap || 0;
            
            // Check the gap/hole field
            const gap = carData.hole || carData.col_11 || '';
            const gapStr = String(gap).trim();
            
            // Pattern 1: "-- 72 laps --" or "-- 74 laps --" - shows actual lap count with dashes
            const dashLapMatch = gapStr.match(/--\s*(\d+)\s*laps?\s*--/i);
            if (dashLapMatch) {
                return parseInt(dashLapMatch[1], 10);
            }
            
            // Pattern 2: "72 laps" or "72 Laps" - shows actual lap count directly
            const directLapMatch = gapStr.match(/^(\d+)\s*laps?$/i);
            if (directLapMatch) {
                return parseInt(directLapMatch[1], 10);
            }
            
            // Pattern 3: "+2 LAPS" or "+2 LAP" - laps behind leader
            const behindMatch = gapStr.match(/\+\s*(\d+)\s*laps?/i);
            if (behindMatch && leaderLap > 0) {
                const lapsDown = parseInt(behindMatch[1], 10);
                return leaderLap - lapsDown;
            }
            
            // Pattern 4: "-1 LAP" or "-2 LAPS" - also laps behind
            const minusMatch = gapStr.match(/-\s*(\d+)\s*laps?/i);
            if (minusMatch && leaderLap > 0) {
                const lapsDown = parseInt(minusMatch[1], 10);
                return leaderLap - lapsDown;
            }
            
            // Pattern 5: Time like "2.913", "46.490", "1:32.959" - on lead lap
            const timeMatch = gapStr.match(/^\d+[:.]\d+/);
            if (timeMatch && leaderLap > 0) {
                return leaderLap;
            }
            
            // If leader lap is set but no pattern matched, assume lead lap
            if (leaderLap > 0) {
                return leaderLap;
            }
            
            return null;
        }
        
        // Record a lap time for a car (with memory cap)
        function recordCarLapTime(carNum, lapTimeValue, carData) {
            const history = initCarHistory(carNum);
            const car = getCar(carNum);
            
            // Parse lap time (use same threshold as main table)
            let timeMs = parseInt(lapTimeValue, 10);
            if (isNaN(timeMs) || timeMs <= 0 || timeMs >= 999999999999) return;
            
            // Calculate actual lap number from leader lap and gap
            let lap = calculateActualLap(carData);
            
            // If we couldn't calculate from gap, try the raw field
            if (lap === null) {
                const lapsRaw = carData.numberoflapscomplete || carData.col_3;
                if (lapsRaw !== undefined && lapsRaw !== null) {
                    const parsed = parseInt(lapsRaw, 10);
                    if (!isNaN(parsed) && parsed > 0 && parsed < 1000) {
                        lap = parsed;
                    }
                }
            }
            
            // If still no lap, infer from history
            if (lap === null || lap <= 0) {
                lap = history.lapTimes.length + 1;
            }
            
            // Update car's lap number
            car.lap = lap;
            
            // Check if we already have this lap
            const existing = history.lapTimes.find(l => l.lap === lap);
            if (existing) return;
            
            // Use pending sectors (captured as they came in before lap time)
            const pending = pendingSectors[carNum] || car.pendingSectors || {};
            const s1 = pending.s1 || null;
            const s2 = pending.s2 || null;
            const s3 = pending.s3 || null; // S3 usually comes after, will be added by addSector3ToLastLap
            
            const lapEntry = {
                lap: lap,
                time: timeMs,
                timeFormatted: formatLapTime(timeMs),
                s1: s1,
                s2: s2,
                s3: s3,
                timestamp: Date.now(),
                pos: parseInt(carData.position || carData.col_0 || '999', 10)
            };
            
            // Use pushCapped for memory safety (endurance races)
            pushCapped(history.lapTimes, lapEntry, MAX_HISTORY);
            pushCapped(car.history.laps, lapEntry, MAX_HISTORY);
            
            // Sort by lap number
            history.lapTimes.sort((a, b) => a.lap - b.lap);
            car.history.laps.sort((a, b) => a.lap - b.lap);
            
            // Update best lap
            if (!history.bestLap || timeMs < history.bestLap.time) {
                history.bestLap = lapEntry;
                car.bestLapTime = timeMs;
                car.bestLapNum = lap;
            }
            
            // Clear pending sectors for this car (S1/S2 were for this lap, S3 will come after)
            if (pendingSectors[carNum]) {
                pendingSectors[carNum].s1 = null;
                pendingSectors[carNum].s2 = null;
            }
            car.pendingSectors.s1 = null;
            car.pendingSectors.s2 = null;
            
            console.log(`[CarHistory] #${carNum} Lap ${lap}: ${lapEntry.timeFormatted} (S1: ${s1 ? (s1/1000000).toFixed(3) : '-'}, S2: ${s2 ? (s2/1000000).toFixed(3) : '-'}, S3: ${s3 ? (s3/1000000).toFixed(3) : 'pending...'})`);
        }
        
        // Add sector 3 to the last recorded lap (S3 comes after lap time)
        function addSector3ToLastLap(carNum, s3Value) {
            const history = carHistory[carNum];
            const car = Store.cars.get(carNum);
            
            // Update legacy history
            if (history && history.lapTimes.length > 0) {
                const lastLap = history.lapTimes[history.lapTimes.length - 1];
                if (lastLap && !lastLap.s3) {
                    lastLap.s3 = s3Value;
                    console.log(`[CarHistory] #${carNum} Lap ${lastLap.lap}: Added S3: ${(s3Value/1000000).toFixed(3)}`);
                }
            }
            
            // Update Store.cars history too
            if (car && car.history.laps.length > 0) {
                const lastLap = car.history.laps[car.history.laps.length - 1];
                if (lastLap && !lastLap.s3) {
                    lastLap.s3 = s3Value;
                }
            }
        }
        
        // Detect pit stops (with memory cap)
        function detectPitStop(carNum, oldValue, newValue, carData) {
            const history = initCarHistory(carNum);
            const car = getCar(carNum);
            const lap = parseInt(carData.numberoflapscomplete || carData.col_3 || '0', 10);
            
            // Check if this is a new pit (oldValue was empty/0 and new value exists)
            const oldNum = parseInt(oldValue, 10) || 0;
            const newNum = parseInt(newValue, 10) || 0;
            
            // If pit time increased significantly, it's a pit stop
            if (newNum > oldNum + 10000000) { // More than 10 seconds added
                const existingPit = history.pitStops.find(p => p.lap === lap);
                if (!existingPit) {
                    const pitEntry = {
                        lap: lap,
                        timestamp: Date.now(),
                        duration: newNum
                    };
                    pushCapped(history.pitStops, pitEntry, 50); // Cap at 50 pit stops
                    pushCapped(car.pitStops, pitEntry, 50);
                    history.totalPits = history.pitStops.length;
                    console.log(`[CarHistory] #${carNum} Pit stop on lap ${lap}`);
                }
            }
        }
        
        // Format lap time from microseconds
        function formatLapTime(microseconds) {
            if (!microseconds || microseconds <= 0) return '-';
            const totalMs = Math.floor(microseconds / 1000);
            const ms = totalMs % 1000;
            const totalSec = Math.floor(totalMs / 1000);
            const sec = totalSec % 60;
            const min = Math.floor(totalSec / 60);
            return `${min}:${String(sec).padStart(2, '0')}.${String(ms).padStart(3, '0')}`;
        }
        
        // Open car analysis modal
        function openCarAnalysis(carNum) {
            if (!comparisonCars.includes(carNum)) {
                comparisonCars.push(carNum);
            }
            document.getElementById('carAnalysisModal').classList.remove('hidden');
            updateAnalysisCarBadges();
            setAnalysisTab('single');
        }
        
        // Close car analysis modal
        function closeCarAnalysis() {
            document.getElementById('carAnalysisModal').classList.add('hidden');
        }
        
        // Add car to comparison
        function addToComparison(carNum) {
            if (!comparisonCars.includes(carNum)) {
                comparisonCars.push(carNum);
                updateAnalysisCarBadges();
                
                // Refresh current tab
                const activeTab = document.querySelector('#analysisTabSingle, #analysisTabCompare, #analysisTabLapTimes')?.style.background?.includes('blue') ? 'single' : 
                                 document.getElementById('analysisTabCompare')?.style.background?.includes('blue') ? 'compare' : 'laptimes';
                setAnalysisTab(activeTab || 'compare');
            }
        }
        
        // Remove car from comparison
        function removeFromComparison(carNum) {
            comparisonCars = comparisonCars.filter(c => c !== carNum);
            updateAnalysisCarBadges();
            setAnalysisTab(comparisonCars.length > 1 ? 'compare' : 'single');
        }
        
        // Clear all comparison cars
        function clearComparison() {
            comparisonCars = [];
            updateAnalysisCarBadges();
            setAnalysisTab('single');
        }
        
        // Update car badges in header
        function updateAnalysisCarBadges() {
            const container = document.getElementById('analysisCarBadges');
            if (!container) return;
            
            const classColors = {
                'LMP2': '#0088ff', 'LMP3': '#9c27b0', 'LMP2 AM': '#ff9800',
                'GT': '#e91e63', 'GT3': '#e91e63', 'GT4': '#8bc34a'
            };
            
            container.innerHTML = comparisonCars.map(carNum => {
                const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
                const carClass = car?.class || car?.col_9 || '';
                const color = classColors[carClass] || '#666';
                
                return `
                    <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: ${color}; border-radius: 4px;">
                        <span style="font-family: 'Orbitron', sans-serif; font-weight: bold; color: #fff;">#${carNum}</span>
                        <button onclick="removeFromComparison('${carNum}')" style="background: none; border: none; color: rgba(255,255,255,0.7); cursor: pointer; font-size: 12px;">‚úï</button>
                    </div>
                `;
            }).join('');
            
            // Add "Add car" button
            container.innerHTML += `
                <div class="dropdown" style="position: relative;">
                    <button onclick="toggleCarDropdown()" style="padding: 4px 10px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; cursor: pointer; font-size: 11px;">+ Add Car</button>
                    <div id="carDropdown" style="display: none; position: absolute; top: 100%; left: 0; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; max-height: 300px; overflow-y: auto; z-index: 1000; min-width: 150px;">
                        ${rows.map(r => {
                            const num = r.startnumber || r.col_2;
                            const pos = r.position || r.col_0;
                            const name = r.name || r.col_4 || '';
                            if (!num || comparisonCars.includes(num)) return '';
                            return `<div onclick="addToComparison('${num}'); toggleCarDropdown();" style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--border-color); font-size: 11px;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'">
                                <span style="font-weight: bold;">P${pos} #${num}</span>
                                <span style="color: var(--text-muted); margin-left: 8px;">${name.substring(0, 20)}</span>
                            </div>`;
                        }).join('')}
                    </div>
                </div>
            `;
        }
        
        // Toggle car dropdown
        function toggleCarDropdown() {
            const dropdown = document.getElementById('carDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Set analysis tab
        let currentAnalysisTab = 'single';
        function setAnalysisTab(tab) {
            currentAnalysisTab = tab;
            
            // Update tab buttons
            ['single', 'compare', 'laptimes'].forEach(t => {
                const btn = document.getElementById('analysisTab' + t.charAt(0).toUpperCase() + t.slice(1));
                if (btn) {
                    btn.style.background = t === tab ? 'var(--accent-blue)' : 'transparent';
                    btn.style.color = t === tab ? '#fff' : 'var(--text-muted)';
                }
            });
            
            // Render content
            const content = document.getElementById('analysisContent');
            if (!content) return;
            
            if (tab === 'single') {
                renderSingleCarAnalysis(content);
            } else if (tab === 'compare') {
                renderHeadToHead(content);
            } else if (tab === 'laptimes') {
                renderLapTimeGraph(content);
            }
        }
        
        // Render single car analysis
        function renderSingleCarAnalysis(container) {
            if (comparisonCars.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-muted);">Click on a car in the timing table to analyze</div>';
                return;
            }
            
            const carNum = comparisonCars[0];
            const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
            const history = carHistory[carNum] || { lapTimes: [], pitStops: [], bestLap: null };
            
            if (!car) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-muted);">Car not found</div>';
                return;
            }
            
            const pos = car.position || car.col_0 || '?';
            const name = car.name || car.col_4 || '';
            const driver = car.currentdriver || car.col_7 || '';
            const carClass = car.class || car.col_9 || '';
            const gap = car.hole || car.col_11 || '';
            const diff = car.diff || car.col_12 || '';
            
            // Parse laps - use calculateActualLap for accurate count
            let laps = calculateActualLap(car);
            if (laps === null || laps <= 0) {
                // Fallback to history count
                laps = history.lapTimes.length;
            }
            
            // Parse lap times - filter invalid values (use same threshold as main table: < 999999999999)
            const parseTime = (val) => {
                if (!val) return null;
                const num = parseInt(val, 10);
                if (isNaN(num) || num <= 0 || num >= 999999999999) return null;
                return num;
            };
            
            const lastLapRaw = parseTime(car.lastroundtime || car.col_13);
            const bestLapRaw = parseTime(car.fastestroundtime || car.col_14);
            
            // Current sector times (live)
            const s1Live = parseTime(car.sectortimes_1 || car.col_16);
            const s2Live = parseTime(car.sectortimes_2 || car.col_17);
            const s3Live = parseTime(car.sectortimes_3 || car.col_18);
            
            // Format sector time
            const formatSector = (val) => {
                if (!val) return '-';
                return (val / 1000000).toFixed(3);
            };
            
            // Calculate performance trend
            const trend = calculatePerformanceTrend(history.lapTimes);
            
            // Format times
            const lastLapFormatted = lastLapRaw ? formatLapTime(lastLapRaw) : '-';
            const bestLapFormatted = bestLapRaw ? formatLapTime(bestLapRaw) : '-';
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: 350px 1fr; gap: 20px; height: 100%;">
                    <!-- Left: Car Info -->
                    <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 20px; overflow-y: auto;">
                        <div style="text-align: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border-color);">
                            <div style="font-family: 'Orbitron', sans-serif; font-size: 48px; font-weight: bold; color: var(--accent-green);">P${pos}</div>
                            <div style="background: var(--accent-red); color: #fff; display: inline-block; padding: 8px 20px; border-radius: 4px; font-family: 'Orbitron', sans-serif; font-size: 24px; font-weight: bold; margin: 10px 0;">#${carNum}</div>
                            <div style="font-size: 16px; color: var(--text-primary); margin-top: 8px;">${name}</div>
                            <div style="font-size: 13px; color: var(--text-secondary);">${driver}</div>
                            <div style="font-size: 12px; color: var(--accent-yellow); margin-top: 5px;">${carClass}</div>
                        </div>
                        
                        <!-- Stats Grid -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div style="text-align: center; padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted);">LAPS</div>
                                <div style="font-size: 20px; font-weight: bold; color: var(--text-primary);">${laps}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted);">PIT STOPS</div>
                                <div style="font-size: 20px; font-weight: bold; color: var(--text-primary);">${history.pitStops.length}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted);">LAST LAP</div>
                                <div style="font-size: 14px; font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${lastLapFormatted}</div>
                            </div>
                            <div style="text-align: center; padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted);">BEST LAP</div>
                                <div style="font-size: 14px; font-family: 'Roboto Mono', monospace; color: var(--accent-green);">${bestLapFormatted}</div>
                            </div>
                        </div>
                        
                        <!-- Live Sectors -->
                        <div style="padding: 12px; background: var(--bg-primary); border-radius: 4px; margin-bottom: 15px;">
                            <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px;">CURRENT SECTORS</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; text-align: center;">
                                <div>
                                    <div style="font-size: 9px; color: var(--text-muted);">S1</div>
                                    <div style="font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${formatSector(s1Live)}</div>
                                </div>
                                <div>
                                    <div style="font-size: 9px; color: var(--text-muted);">S2</div>
                                    <div style="font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${formatSector(s2Live)}</div>
                                </div>
                                <div>
                                    <div style="font-size: 9px; color: var(--text-muted);">S3</div>
                                    <div style="font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${formatSector(s3Live)}</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Gaps -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <div style="padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">GAP TO LEADER</div>
                                <div style="font-size: 14px; font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${gap || '-'}</div>
                            </div>
                            <div style="padding: 12px; background: var(--bg-primary); border-radius: 4px;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">GAP TO CAR AHEAD</div>
                                <div style="font-size: 14px; font-family: 'Roboto Mono', monospace; color: var(--text-primary);">${diff || '-'}</div>
                            </div>
                        </div>
                        
                        <!-- Performance Trend -->
                        <div style="padding: 15px; background: var(--bg-primary); border-radius: 4px;">
                            <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px;">PERFORMANCE TREND</div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 24px;">${trend.icon}</span>
                                <div>
                                    <div style="font-size: 14px; font-weight: bold; color: ${trend.color};">${trend.text}</div>
                                    <div style="font-size: 11px; color: var(--text-muted);">${trend.detail}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right: Lap Time History -->
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <!-- Mini Lap Time Chart -->
                        <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 15px; height: 200px;">
                            <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 10px;">LAP TIME PROGRESSION</div>
                            <div id="singleCarChart" style="height: calc(100% - 25px);"></div>
                        </div>
                        
                        <!-- Lap Time Table -->
                        <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 15px; flex: 1; overflow-y: auto;">
                            <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 10px;">LAP TIME HISTORY (${history.lapTimes.length} laps recorded)</div>
                            <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                <thead>
                                    <tr style="border-bottom: 1px solid var(--border-color);">
                                        <th style="text-align: left; padding: 8px; color: var(--text-muted);">LAP</th>
                                        <th style="text-align: right; padding: 8px; color: var(--text-muted);">TIME</th>
                                        <th style="text-align: right; padding: 8px; color: var(--text-muted);">S1</th>
                                        <th style="text-align: right; padding: 8px; color: var(--text-muted);">S2</th>
                                        <th style="text-align: right; padding: 8px; color: var(--text-muted);">S3</th>
                                        <th style="text-align: center; padding: 8px; color: var(--text-muted);">POS</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${history.lapTimes.slice().reverse().map(lap => {
                                        const isBest = history.bestLap && lap.time === history.bestLap.time;
                                        return `
                                            <tr style="border-bottom: 1px solid var(--border-color); ${isBest ? 'background: rgba(0,255,136,0.1);' : ''}">
                                                <td style="padding: 8px; color: var(--text-primary);">${lap.lap}</td>
                                                <td style="padding: 8px; text-align: right; font-family: 'Roboto Mono', monospace; color: ${isBest ? 'var(--accent-green)' : 'var(--text-primary)'};">${lap.timeFormatted}</td>
                                                <td style="padding: 8px; text-align: right; font-family: 'Roboto Mono', monospace; color: var(--text-secondary);">${lap.s1 ? (lap.s1/1000000).toFixed(3) : '-'}</td>
                                                <td style="padding: 8px; text-align: right; font-family: 'Roboto Mono', monospace; color: var(--text-secondary);">${lap.s2 ? (lap.s2/1000000).toFixed(3) : '-'}</td>
                                                <td style="padding: 8px; text-align: right; font-family: 'Roboto Mono', monospace; color: var(--text-secondary);">${lap.s3 ? (lap.s3/1000000).toFixed(3) : '-'}</td>
                                                <td style="padding: 8px; text-align: center; color: var(--text-muted);">P${lap.pos}</td>
                                            </tr>
                                        `;
                                    }).join('') || '<tr><td colspan="6" style="padding: 20px; text-align: center; color: var(--text-muted);">No lap times recorded yet. Data is captured as laps complete.</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            // Render mini chart
            renderSingleCarChart(history.lapTimes);
        }
        
        // Calculate performance trend from lap times
        function calculatePerformanceTrend(lapTimes) {
            if (lapTimes.length < 3) {
                return { icon: '‚ûñ', text: 'Not enough data', detail: 'Need at least 3 laps', color: 'var(--text-muted)' };
            }
            
            // Compare last 3 laps average to previous 3 laps average
            const recent = lapTimes.slice(-3);
            const previous = lapTimes.slice(-6, -3);
            
            if (previous.length < 3) {
                const avgRecent = recent.reduce((a, b) => a + b.time, 0) / recent.length;
                const avgTime = formatLapTime(avgRecent);
                return { icon: 'üìä', text: 'Building data', detail: `Avg: ${avgTime}`, color: 'var(--text-secondary)' };
            }
            
            const avgRecent = recent.reduce((a, b) => a + b.time, 0) / recent.length;
            const avgPrevious = previous.reduce((a, b) => a + b.time, 0) / previous.length;
            const diff = avgRecent - avgPrevious;
            const diffSec = (diff / 1000000).toFixed(2);
            
            if (diff < -500000) { // Improved by 0.5s+
                return { icon: 'üöÄ', text: 'IMPROVING', detail: `${diffSec}s faster`, color: 'var(--accent-green)' };
            } else if (diff < 0) {
                return { icon: 'üìà', text: 'Slightly faster', detail: `${diffSec}s`, color: 'var(--accent-green)' };
            } else if (diff > 500000) { // Slower by 0.5s+
                return { icon: 'üìâ', text: 'DEGRADING', detail: `+${diffSec}s slower`, color: 'var(--accent-red)' };
            } else if (diff > 0) {
                return { icon: '‚û°Ô∏è', text: 'Slightly slower', detail: `+${diffSec}s`, color: 'var(--accent-yellow)' };
            } else {
                return { icon: '‚ûñ', text: 'Consistent', detail: 'Stable pace', color: 'var(--text-secondary)' };
            }
        }
        
        // Render mini chart for single car
        function renderSingleCarChart(lapTimes) {
            const container = document.getElementById('singleCarChart');
            if (!container || lapTimes.length === 0) {
                if (container) container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">No lap data yet</div>';
                return;
            }
            
            const width = container.offsetWidth || 400;
            const height = container.offsetHeight || 150;
            const padding = { top: 10, right: 10, bottom: 25, left: 50 };
            
            const times = lapTimes.map(l => l.time);
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeRange = maxTime - minTime || 1000000;
            
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}">`;
            
            // Draw grid and axis
            const ySteps = 4;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding.top + (i / ySteps) * (height - padding.top - padding.bottom);
                const timeVal = maxTime - (i / ySteps) * timeRange;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="rgba(255,255,255,0.1)"/>`;
                svg += `<text x="${padding.left - 5}" y="${y + 4}" fill="rgba(255,255,255,0.4)" font-size="9" text-anchor="end">${formatLapTime(timeVal)}</text>`;
            }
            
            // Draw line and points
            let pathData = '';
            lapTimes.forEach((lap, i) => {
                const x = padding.left + (i / Math.max(1, lapTimes.length - 1)) * (width - padding.left - padding.right);
                const y = padding.top + ((maxTime - lap.time) / timeRange) * (height - padding.top - padding.bottom);
                
                if (i === 0) pathData = `M ${x} ${y}`;
                else pathData += ` L ${x} ${y}`;
            });
            
            svg += `<path d="${pathData}" fill="none" stroke="var(--accent-blue)" stroke-width="2"/>`;
            
            // Draw points
            lapTimes.forEach((lap, i) => {
                const x = padding.left + (i / Math.max(1, lapTimes.length - 1)) * (width - padding.left - padding.right);
                const y = padding.top + ((maxTime - lap.time) / timeRange) * (height - padding.top - padding.bottom);
                const isBest = lap.time === minTime;
                
                svg += `<circle cx="${x}" cy="${y}" r="${isBest ? 5 : 3}" fill="${isBest ? 'var(--accent-green)' : 'var(--accent-blue)'}"/>`;
            });
            
            svg += '</svg>';
            container.innerHTML = svg;
        }
        
        // Render head to head comparison
        function renderHeadToHead(container) {
            if (comparisonCars.length < 2) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-muted);">Add at least 2 cars to compare (use + Add Car button)</div>';
                return;
            }
            
            const classColors = {
                'LMP2': '#0088ff', 'LMP3': '#9c27b0', 'LMP2 AM': '#ff9800',
                'GT': '#e91e63', 'GT3': '#e91e63', 'GT4': '#8bc34a'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#4caf50', '#ff5722', '#795548'];
            
            // Helper to parse laps
            const parseLaps = (val) => {
                if (!val) return 0;
                const num = parseInt(String(val).replace(/[^0-9]/g, ''), 10);
                return isNaN(num) ? 0 : num;
            };
            
            // Helper to parse time (filter invalid values, same threshold as main table)
            const parseTimeVal = (val) => {
                if (!val) return null;
                const num = parseInt(val, 10);
                if (isNaN(num) || num <= 0 || num >= 999999999999) return null;
                return num;
            };
            
            let html = '<div style="display: grid; gap: 20px;">';
            
            // Comparison table
            html += '<div style="background: var(--bg-tertiary); border-radius: 8px; padding: 20px;">';
            html += '<div style="font-size: 11px; color: var(--text-muted); margin-bottom: 15px;">COMPARISON</div>';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="border-bottom: 2px solid var(--border-color);">';
            html += '<th style="text-align: left; padding: 10px; color: var(--text-muted);">METRIC</th>';
            
            comparisonCars.forEach((carNum, i) => {
                const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
                const carClass = car?.class || car?.col_9 || '';
                const color = classColors[carClass] || defaultColors[i % defaultColors.length];
                html += `<th style="text-align: center; padding: 10px; color: ${color}; font-family: 'Orbitron', sans-serif;">#${carNum}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            // Rows: Position, Laps, Best Lap, Last Lap, Pit Stops, Gap
            const metrics = ['Position', 'Laps', 'Best Lap', 'Last Lap', 'Avg Lap (last 5)', 'Pit Stops', 'Gap to Leader'];
            
            metrics.forEach(metric => {
                html += `<tr style="border-bottom: 1px solid var(--border-color);">`;
                html += `<td style="padding: 12px; color: var(--text-secondary);">${metric}</td>`;
                
                let values = comparisonCars.map(carNum => {
                    const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
                    const history = carHistory[carNum] || { lapTimes: [], pitStops: [] };
                    
                    switch(metric) {
                        case 'Position': 
                            const pos = parseInt(car?.position || car?.col_0 || '999', 10);
                            return { val: pos, display: 'P' + pos };
                        case 'Laps': 
                            let laps = car ? calculateActualLap(car) : 0;
                            if (!laps || laps <= 0) laps = history.lapTimes.length;
                            return { val: laps, display: String(laps) };
                        case 'Best Lap': 
                            const best = parseTimeVal(car?.fastestroundtime || car?.col_14);
                            return { val: best || 999999999, display: best ? formatLapTime(best) : '-' };
                        case 'Last Lap':
                            const last = parseTimeVal(car?.lastroundtime || car?.col_13);
                            return { val: last || 999999999, display: last ? formatLapTime(last) : '-' };
                        case 'Avg Lap (last 5)':
                            const recent = history.lapTimes.slice(-5);
                            if (recent.length === 0) return { val: 999999999, display: '-' };
                            const avg = recent.reduce((a, b) => a + b.time, 0) / recent.length;
                            return { val: avg, display: formatLapTime(avg) };
                        case 'Pit Stops': return { val: history.pitStops.length, display: String(history.pitStops.length) };
                        case 'Gap to Leader': return { val: 0, display: car?.hole || car?.col_11 || '-' };
                        default: return { val: 0, display: '-' };
                    }
                });
                
                // Find best value (lowest for times/position, could be different for other metrics)
                const isBestLowest = ['Position', 'Best Lap', 'Last Lap', 'Avg Lap (last 5)'].includes(metric);
                const validVals = values.map(v => v.val).filter(v => v < 999999999);
                const bestVal = validVals.length > 0 ? (isBestLowest ? Math.min(...validVals) : Math.max(...validVals)) : null;
                
                values.forEach((v, i) => {
                    const isBest = bestVal !== null && v.val === bestVal && v.val < 999999999;
                    
                    html += `<td style="padding: 12px; text-align: center; font-family: 'Roboto Mono', monospace; ${isBest ? `color: var(--accent-green); font-weight: bold;` : `color: var(--text-primary);`}">${v.display}</td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Gap evolution chart
            html += '<div style="background: var(--bg-tertiary); border-radius: 8px; padding: 20px;">';
            html += '<div style="font-size: 11px; color: var(--text-muted); margin-bottom: 10px;">LAP TIME COMPARISON</div>';
            html += '<div id="headToHeadChart" style="height: 250px;"></div>';
            html += '</div>';
            
            html += '</div>';
            
            container.innerHTML = html;
            
            // Render chart
            renderHeadToHeadChart();
        }
        
        // Render head to head lap time chart
        function renderHeadToHeadChart() {
            const container = document.getElementById('headToHeadChart');
            if (!container) return;
            
            const classColors = {
                'LMP2': '#0088ff', 'LMP3': '#9c27b0', 'LMP2 AM': '#ff9800',
                'GT': '#e91e63', 'GT3': '#e91e63', 'GT4': '#8bc34a'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#4caf50', '#ff5722', '#795548'];
            
            // Get all lap times
            let allLaps = [];
            let minTime = Infinity, maxTime = 0;
            
            comparisonCars.forEach(carNum => {
                const history = carHistory[carNum] || { lapTimes: [] };
                history.lapTimes.forEach(l => {
                    allLaps.push(l.lap);
                    if (l.time < minTime) minTime = l.time;
                    if (l.time > maxTime) maxTime = l.time;
                });
            });
            
            if (allLaps.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">No lap data recorded yet</div>';
                return;
            }
            
            const minLap = Math.min(...allLaps);
            const maxLap = Math.max(...allLaps);
            const timeRange = maxTime - minTime || 1000000;
            
            const width = container.offsetWidth || 600;
            const height = 250;
            const padding = { top: 20, right: 20, bottom: 30, left: 60 };
            
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}">`;
            
            // Grid
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding.top + (i / ySteps) * (height - padding.top - padding.bottom);
                const timeVal = maxTime - (i / ySteps) * timeRange;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="rgba(255,255,255,0.1)"/>`;
                svg += `<text x="${padding.left - 5}" y="${y + 4}" fill="rgba(255,255,255,0.4)" font-size="9" text-anchor="end">${formatLapTime(timeVal)}</text>`;
            }
            
            // X axis
            const lapRange = maxLap - minLap || 1;
            for (let l = minLap; l <= maxLap; l += Math.ceil(lapRange / 10)) {
                const x = padding.left + ((l - minLap) / lapRange) * (width - padding.left - padding.right);
                svg += `<text x="${x}" y="${height - 10}" fill="rgba(255,255,255,0.4)" font-size="9" text-anchor="middle">L${l}</text>`;
            }
            
            // Draw lines for each car
            comparisonCars.forEach((carNum, idx) => {
                const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
                const carClass = car?.class || car?.col_9 || '';
                const color = classColors[carClass] || defaultColors[idx % defaultColors.length];
                const history = carHistory[carNum] || { lapTimes: [] };
                
                if (history.lapTimes.length === 0) return;
                
                let pathData = '';
                history.lapTimes.forEach((lap, i) => {
                    const x = padding.left + ((lap.lap - minLap) / lapRange) * (width - padding.left - padding.right);
                    const y = padding.top + ((maxTime - lap.time) / timeRange) * (height - padding.top - padding.bottom);
                    
                    if (pathData === '') pathData = `M ${x} ${y}`;
                    else pathData += ` L ${x} ${y}`;
                });
                
                svg += `<path d="${pathData}" fill="none" stroke="${color}" stroke-width="2" opacity="0.8"/>`;
                
                // End label
                const lastLap = history.lapTimes[history.lapTimes.length - 1];
                const x = padding.left + ((lastLap.lap - minLap) / lapRange) * (width - padding.left - padding.right);
                const y = padding.top + ((maxTime - lastLap.time) / timeRange) * (height - padding.top - padding.bottom);
                svg += `<circle cx="${x}" cy="${y}" r="4" fill="${color}"/>`;
                svg += `<text x="${x + 8}" y="${y + 4}" fill="${color}" font-size="10" font-weight="bold">#${carNum}</text>`;
            });
            
            svg += '</svg>';
            container.innerHTML = svg;
        }
        
        // Render lap time graph for all selected cars
        function renderLapTimeGraph(container) {
            if (comparisonCars.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-muted);">Add cars to see lap time graph</div>';
                return;
            }
            
            container.innerHTML = `
                <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 20px; height: calc(100% - 40px);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="font-size: 11px; color: var(--text-muted);">LAP TIME GRAPH</div>
                        <div style="display: flex; gap: 10px;">
                            <label style="font-size: 10px; color: var(--text-muted); display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="showAvgLine" onchange="renderLapTimeGraphChart()" checked> Show average
                            </label>
                        </div>
                    </div>
                    <div id="lapTimeGraphChart" style="height: calc(100% - 40px);"></div>
                </div>
            `;
            
            renderLapTimeGraphChart();
        }
        
        function renderLapTimeGraphChart() {
            const container = document.getElementById('lapTimeGraphChart');
            if (!container) return;
            
            const showAvg = document.getElementById('showAvgLine')?.checked ?? true;
            
            const classColors = {
                'LMP2': '#0088ff', 'LMP3': '#9c27b0', 'LMP2 AM': '#ff9800',
                'GT': '#e91e63', 'GT3': '#e91e63', 'GT4': '#8bc34a'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#4caf50', '#ff5722', '#795548', '#607d8b'];
            
            // Collect data
            let allLaps = [];
            let minTime = Infinity, maxTime = 0;
            
            comparisonCars.forEach(carNum => {
                const history = carHistory[carNum] || { lapTimes: [] };
                history.lapTimes.forEach(l => {
                    allLaps.push(l.lap);
                    if (l.time < minTime) minTime = l.time;
                    if (l.time > maxTime) maxTime = l.time;
                });
            });
            
            if (allLaps.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">No lap data recorded yet. Data is captured as cars complete laps.</div>';
                return;
            }
            
            const minLap = Math.min(...allLaps);
            const maxLap = Math.max(...allLaps);
            // Add 5% padding to time range
            const timeRange = (maxTime - minTime) * 1.1 || 1000000;
            minTime = minTime - timeRange * 0.05;
            
            const width = container.offsetWidth || 800;
            const height = container.offsetHeight || 400;
            const padding = { top: 30, right: 100, bottom: 40, left: 70 };
            
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}">`;
            
            // Title
            svg += `<text x="${width/2}" y="15" fill="var(--text-secondary)" font-size="12" text-anchor="middle">Lap Times Over Race</text>`;
            
            // Grid
            const ySteps = 6;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding.top + (i / ySteps) * (height - padding.top - padding.bottom);
                const timeVal = maxTime + timeRange * 0.05 - (i / ySteps) * timeRange;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="rgba(255,255,255,0.1)"/>`;
                svg += `<text x="${padding.left - 8}" y="${y + 4}" fill="rgba(255,255,255,0.5)" font-size="10" text-anchor="end">${formatLapTime(timeVal)}</text>`;
            }
            
            // X axis
            const lapRange = maxLap - minLap || 1;
            const xSteps = Math.min(lapRange, 15);
            for (let i = 0; i <= xSteps; i++) {
                const l = Math.round(minLap + (i / xSteps) * lapRange);
                const x = padding.left + ((l - minLap) / lapRange) * (width - padding.left - padding.right);
                svg += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" stroke="rgba(255,255,255,0.05)"/>`;
                svg += `<text x="${x}" y="${height - padding.bottom + 18}" fill="rgba(255,255,255,0.5)" font-size="10" text-anchor="middle">${l}</text>`;
            }
            
            // Axis labels
            svg += `<text x="${width/2}" y="${height - 5}" fill="rgba(255,255,255,0.5)" font-size="11" text-anchor="middle">Lap Number</text>`;
            svg += `<text x="15" y="${height/2}" fill="rgba(255,255,255,0.5)" font-size="11" text-anchor="middle" transform="rotate(-90, 15, ${height/2})">Lap Time</text>`;
            
            // Draw lines for each car
            let legendY = padding.top + 10;
            
            comparisonCars.forEach((carNum, idx) => {
                const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
                const carClass = car?.class || car?.col_9 || '';
                const color = classColors[carClass] || defaultColors[idx % defaultColors.length];
                const history = carHistory[carNum] || { lapTimes: [] };
                
                if (history.lapTimes.length === 0) return;
                
                // Calculate average
                const avgTime = history.lapTimes.reduce((a, b) => a + b.time, 0) / history.lapTimes.length;
                
                // Draw average line
                if (showAvg) {
                    const avgY = padding.top + ((maxTime + timeRange * 0.05 - avgTime) / timeRange) * (height - padding.top - padding.bottom);
                    svg += `<line x1="${padding.left}" y1="${avgY}" x2="${width - padding.right}" y2="${avgY}" stroke="${color}" stroke-width="1" stroke-dasharray="4,4" opacity="0.5"/>`;
                }
                
                // Draw line
                let pathData = '';
                history.lapTimes.forEach((lap, i) => {
                    const x = padding.left + ((lap.lap - minLap) / lapRange) * (width - padding.left - padding.right);
                    const y = padding.top + ((maxTime + timeRange * 0.05 - lap.time) / timeRange) * (height - padding.top - padding.bottom);
                    
                    if (pathData === '') pathData = `M ${x} ${y}`;
                    else pathData += ` L ${x} ${y}`;
                });
                
                svg += `<path d="${pathData}" fill="none" stroke="${color}" stroke-width="2"/>`;
                
                // Draw points
                history.lapTimes.forEach((lap, i) => {
                    const x = padding.left + ((lap.lap - minLap) / lapRange) * (width - padding.left - padding.right);
                    const y = padding.top + ((maxTime + timeRange * 0.05 - lap.time) / timeRange) * (height - padding.top - padding.bottom);
                    svg += `<circle cx="${x}" cy="${y}" r="3" fill="${color}"><title>Lap ${lap.lap}: ${lap.timeFormatted}</title></circle>`;
                });
                
                // Legend
                const legendX = width - padding.right + 10;
                svg += `<rect x="${legendX}" y="${legendY - 6}" width="12" height="12" fill="${color}" rx="2"/>`;
                svg += `<text x="${legendX + 18}" y="${legendY + 4}" fill="var(--text-primary)" font-size="11" font-weight="bold">#${carNum}</text>`;
                legendY += 20;
            });
            
            svg += '</svg>';
            container.innerHTML = svg;
        }
        
        function updateTrackFullscreen() {
            if (rows.length === 0) return;
            
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            renderFullscreenTrack(sortedRows);
        }
        
        // Show car info on hover in fullscreen
        function showCarInfo(carNum) {
            const infoPanel = document.getElementById('trackModalInfo');
            if (!infoPanel) return;
            
            // Find car data
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            const carIndex = sortedRows.findIndex(r => (r.startnumber || r.col_2) === carNum);
            if (carIndex === -1) return;
            
            const car = sortedRows[carIndex];
            const carAhead = carIndex > 0 ? sortedRows[carIndex - 1] : null;
            const carBehind = carIndex < sortedRows.length - 1 ? sortedRows[carIndex + 1] : null;
            
            const pos = car.position || car.col_0 || '?';
            const name = car.name || car.col_4 || '';
            const driver = car.currentdriver || car.col_7 || '';
            const carClass = car.class || car.col_9 || '';
            const gapToLeader = car.hole || car.col_11 || '';
            const gapAhead = car.diff || car.col_12 || '';
            const lastLap = car.lastroundtime || car.col_13 || '';
            const bestLap = car.fastestroundtime || car.col_14 || '';
            const laps = car.numberoflapscomplete || car.col_3 || '';
            
            // Format lap times
            let lastLapFormatted = lastLap;
            let bestLapFormatted = bestLap;
            const lastLapVal = parseInt(lastLap, 10);
            const bestLapVal = parseInt(bestLap, 10);
            if (!isNaN(lastLapVal) && lastLapVal > 1000000 && lastLapVal < 999999999999) {
                lastLapFormatted = formatTime(lastLapVal);
            }
            if (!isNaN(bestLapVal) && bestLapVal > 1000000 && bestLapVal < 999999999999) {
                bestLapFormatted = formatTime(bestLapVal);
            }
            
            // Get car ahead info
            let aheadHtml = '<div style="color: var(--text-muted); text-align: center; padding: 10px;">Leading the race</div>';
            if (carAhead) {
                const aheadNum = carAhead.startnumber || carAhead.col_2 || '?';
                const aheadName = carAhead.name || carAhead.col_4 || '';
                const aheadLastLap = carAhead.lastroundtime || carAhead.col_13 || '';
                let aheadLastLapFormatted = aheadLastLap;
                const aheadLastLapVal = parseInt(aheadLastLap, 10);
                if (!isNaN(aheadLastLapVal) && aheadLastLapVal > 1000000 && aheadLastLapVal < 999999999999) {
                    aheadLastLapFormatted = formatTime(aheadLastLapVal);
                }
                
                aheadHtml = `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--bg-primary); border-radius: 4px;">
                        <div>
                            <div style="font-size: 11px; color: var(--text-muted);">P${parseInt(pos) - 1}</div>
                            <div style="font-weight: bold; color: var(--text-primary);">#${aheadNum}</div>
                            <div style="font-size: 10px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px;">${aheadName}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-muted);">Last lap</div>
                            <div style="font-family: 'Roboto Mono', monospace; color: var(--text-secondary);">${aheadLastLapFormatted || '-'}</div>
                        </div>
                    </div>
                    <div style="text-align: center; padding: 6px; color: var(--accent-yellow); font-family: 'Roboto Mono', monospace; font-weight: bold;">
                        GAP: ${gapAhead || '-'}
                    </div>
                `;
            }
            
            // Get car behind info
            let behindHtml = '<div style="color: var(--text-muted); text-align: center; padding: 10px;">Last position</div>';
            if (carBehind) {
                const behindNum = carBehind.startnumber || carBehind.col_2 || '?';
                const behindName = carBehind.name || carBehind.col_4 || '';
                const behindGap = carBehind.diff || carBehind.col_12 || '';
                const behindLastLap = carBehind.lastroundtime || carBehind.col_13 || '';
                let behindLastLapFormatted = behindLastLap;
                const behindLastLapVal = parseInt(behindLastLap, 10);
                if (!isNaN(behindLastLapVal) && behindLastLapVal > 1000000 && behindLastLapVal < 999999999999) {
                    behindLastLapFormatted = formatTime(behindLastLapVal);
                }
                
                behindHtml = `
                    <div style="text-align: center; padding: 6px; color: var(--accent-red); font-family: 'Roboto Mono', monospace; font-weight: bold;">
                        GAP: ${behindGap || '-'}
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--bg-primary); border-radius: 4px;">
                        <div>
                            <div style="font-size: 11px; color: var(--text-muted);">P${parseInt(pos) + 1}</div>
                            <div style="font-weight: bold; color: var(--text-primary);">#${behindNum}</div>
                            <div style="font-size: 10px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px;">${behindName}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 10px; color: var(--text-muted);">Last lap</div>
                            <div style="font-family: 'Roboto Mono', monospace; color: var(--text-secondary);">${behindLastLapFormatted || '-'}</div>
                        </div>
                    </div>
                `;
            }
            
            infoPanel.innerHTML = `
                <!-- Car Header -->
                <div style="text-align: center; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 32px; font-weight: bold; color: var(--accent-green);">P${pos}</div>
                    <div style="background: var(--accent-red); color: #fff; display: inline-block; padding: 6px 16px; border-radius: 4px; font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: bold; margin: 8px 0;">#${carNum}</div>
                    <div style="font-size: 13px; color: var(--text-primary); margin-top: 5px;">${name}</div>
                    <div style="font-size: 11px; color: var(--text-secondary);">${driver}</div>
                    <div style="font-size: 11px; color: var(--accent-yellow); margin-top: 5px;">${carClass}</div>
                </div>
                
                <!-- Lap Times -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                    <div style="text-align: center; padding: 10px; background: var(--bg-primary); border-radius: 4px;">
                        <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">LAST LAP</div>
                        <div style="font-family: 'Roboto Mono', monospace; font-size: 14px; color: var(--text-primary);">${lastLapFormatted || '-'}</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background: var(--bg-primary); border-radius: 4px;">
                        <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">BEST LAP</div>
                        <div style="font-family: 'Roboto Mono', monospace; font-size: 14px; color: var(--accent-green);">${bestLapFormatted || '-'}</div>
                    </div>
                </div>
                
                <!-- Stats Row -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                    <div style="text-align: center; padding: 8px; background: var(--bg-primary); border-radius: 4px;">
                        <div style="font-size: 10px; color: var(--text-muted);">LAPS</div>
                        <div style="font-size: 16px; font-weight: bold; color: var(--text-primary);">${laps || '-'}</div>
                    </div>
                    <div style="text-align: center; padding: 8px; background: var(--bg-primary); border-radius: 4px;">
                        <div style="font-size: 10px; color: var(--text-muted);">TO LEADER</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${gapToLeader || '-'}</div>
                    </div>
                </div>
                
                <!-- Car Ahead -->
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 6px; display: flex; align-items: center; gap: 5px;">
                        <span>‚ñ≤</span> CAR AHEAD
                    </div>
                    ${aheadHtml}
                </div>
                
                <!-- Car Behind -->
                <div>
                    <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 6px; display: flex; align-items: center; gap: 5px;">
                        <span>‚ñº</span> CAR BEHIND
                    </div>
                    ${behindHtml}
                </div>
                
                <!-- Track Button -->
                <button onclick="trackCar('${carNum}'); closeTrackFullscreen();" style="width: 100%; margin-top: 15px; padding: 10px; background: var(--accent-green); color: #000; border: none; border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-weight: bold;">
                    üéØ TRACK THIS CAR
                </button>
                <button onclick="openCarAnalysis('${carNum}'); closeTrackFullscreen();" style="width: 100%; margin-top: 8px; padding: 10px; background: var(--accent-blue); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: 'Orbitron', sans-serif; font-weight: bold;">
                    üìä ANALYZE
                </button>
            `;
        }
        
        // Get filtered cars for fullscreen track
        function getTrackModalFilteredCars() {
            const input = document.getElementById('trackModalFilter');
            if (!input || !input.value.trim()) return null;
            const numbers = input.value.split(',').map(n => n.trim()).filter(n => n.length > 0);
            return numbers.length > 0 ? numbers : null;
        }
        

        // ===========================================
        // TRACK ANIMATION: Elapsed time based position
        // ===========================================
        const trackAnimationState = {
            cars: new Map(),
            animationId: null,
            isRunning: false,
            logEnabled: true,      // Set to false to disable all logging
            logPositions: false,   // Set to true to log position updates (noisy!)
            logInterval: 10000     // Log position every 10 seconds per car (if enabled)
        };
        
        // Logging helper
        function trackLog(carNum, type, message, data = {}) {
            if (!trackAnimationState.logEnabled) return;
            const timestamp = new Date().toLocaleTimeString();
            const prefix = `[Track ${timestamp}] #${carNum}`;
            
            if (type === 'NEW_LAP') {
                console.log(`%c${prefix} üèÅ NEW LAP`, 'color: #00ff00; font-weight: bold', message, data);
            } else if (type === 'INIT') {
                console.log(`%c${prefix} üöó INIT`, 'color: #00bcd4; font-weight: bold', message, data);
            } else if (type === 'PIT') {
                console.log(`%c${prefix} üîß PIT`, 'color: #ffcc00; font-weight: bold', message, data);
            } else if (type === 'POSITION') {
                console.log(`%c${prefix} üìç POS`, 'color: #888', message, data);
            } else if (type === 'WAITING') {
                console.log(`%c${prefix} ‚è≥ WAITING`, 'color: #ff6600', message, data);
            } else {
                console.log(`${prefix}`, message, data);
            }
        }
        
        // Initialize/update car animation state from incoming data
        function updateCarAnimationState(car) {
            const carNum = car.startnumber || car.col_2 || '?';
            const state = car.state || car.col_6 || '';
            const now = Date.now();
            
            // Parse sector times (microseconds -> seconds)
            // These are used for PACING only (how fast to animate through each sector)
            // Valid range: 5-300 seconds (reject placeholder values like MAX_INT64)
            const s1Raw = car.sectortimes_1 || car.col_16;
            const s2Raw = car.sectortimes_2 || car.col_17;
            const s3Raw = car.sectortimes_3 || car.col_18;
            
            const s1Parsed = parseInt(s1Raw);
            const s2Parsed = parseInt(s2Raw);
            const s3Parsed = parseInt(s3Raw);
            
            // Valid sector time: between 5 and 300 seconds (5M to 300M microseconds)
            const isValidSector = (val) => val > 5000000 && val < 300000000;
            
            const s1Sec = isValidSector(s1Parsed) ? s1Parsed / 1000000 : 35;
            const s2Sec = isValidSector(s2Parsed) ? s2Parsed / 1000000 : 35;
            const s3Sec = isValidSector(s3Parsed) ? s3Parsed / 1000000 : 30;
            
            // Get or create car state
            let carState = trackAnimationState.cars.get(carNum);
            
            if (!carState) {
                const totalLapTime = s1Sec + s2Sec + s3Sec;
                
                // Spread cars initially based on race position
                const racePos = parseInt(car.position || car.col_0 || '1');
                const totalCars = rows.length || 50;
                const spreadRatio = (totalCars - racePos) / Math.max(totalCars, 1);
                const initialElapsedSec = spreadRatio * totalLapTime * 0.85;
                
                carState = {
                    lapStartTime: now - (initialElapsedSec * 1000),
                    lastLapNum: parseInt(car.laps || car.col_10 || '0'),
                    sectorTimes: [s1Sec, s2Sec, s3Sec],
                    inPit: false,
                    sector: 1,
                    lastLogTime: 0
                };
                trackAnimationState.cars.set(carNum, carState);
                
                trackLog(carNum, 'INIT', `Created at lap ${carState.lastLapNum}, spread ${(spreadRatio*100).toFixed(0)}%`, {
                    initialElapsed: initialElapsedSec.toFixed(1) + 's',
                    sectorTimes: `S1=${s1Sec.toFixed(1)} S2=${s2Sec.toFixed(1)} S3=${s3Sec.toFixed(1)}`,
                    totalLap: totalLapTime.toFixed(1) + 's'
                });
            }
            
            // Always update sector times for pacing
            carState.sectorTimes = [s1Sec, s2Sec, s3Sec];
            
            // Check pit status
            const wasInPit = carState.inPit;
            const stateStr = (state || '').toString().toLowerCase();
            carState.inPit = stateStr.includes('pit') || stateStr === 'p' || stateStr === 'in';
            
            // Left pit - start new lap
            if (wasInPit && !carState.inPit) {
                carState.lapStartTime = now;
                trackLog(carNum, 'PIT', 'Left pit, starting new lap');
            }
            
            // Entered pit
            if (!wasInPit && carState.inPit) {
                trackLog(carNum, 'PIT', 'Entered pit');
            }
            
            // NEW LAP DETECTION: lap count increased
            // When this happens, car has JUST crossed S/F line
            // S3 time will update AFTER this (it's from previous lap) - ignore it
            const currentLap = parseInt(car.laps || car.col_10 || '0');
            if (currentLap > carState.lastLapNum && currentLap > 0) {
                const oldLap = carState.lastLapNum;
                const elapsedSinceLapStart = (now - carState.lapStartTime) / 1000;
                
                // Car crossed S/F - start at position 0, begin S1
                carState.lapStartTime = now;
                carState.lastLapNum = currentLap;
                
                trackLog(carNum, 'NEW_LAP', `Lap ${oldLap} -> ${currentLap}`, {
                    previousLapElapsed: elapsedSinceLapStart.toFixed(1) + 's',
                    expectedLap: (s1Sec + s2Sec + s3Sec).toFixed(1) + 's',
                    sectorTimes: `S1=${s1Sec.toFixed(1)} S2=${s2Sec.toFixed(1)} S3=${s3Sec.toFixed(1)}`
                });
            }
            
            return carState;
        }
        
        // Calculate position based on tracker data OR elapsed time
        function calculateCarTrackPosition(carState, carNum = '?') {
            if (carState.inPit || carState.trackerInPit) return null;
            
            const now = Date.now();
            
            // If we have recent tracker data (within last 5 seconds), use it
            if (carState.lastTrackerUpdate && (now - carState.lastTrackerUpdate) < 5000) {
                const trackerPos = carState.trackerPos;
                const sector = carState.trackerSector || 1;
                
                // Log to understand the scale (only occasionally)
                if (now - (carState.lastTrackerLog || 0) > 10000) {
                    carState.lastTrackerLog = now;
                    console.log(`[Tracker] #${carNum} sector=${sector} pos=${trackerPos}`);
                }
                
                // Convert tracker position to 0-1 range
                // Assuming trackPos is a value that represents position within track
                // Let's try: if trackerPos is 0-10000000, divide by 10000000
                // Or if it's smaller, maybe 0-100000 range
                let position;
                
                if (trackerPos > 100000) {
                    // Large numbers - assume 0-10000000 scale
                    position = trackerPos / 10000000;
                } else {
                    // Smaller - assume 0-100 or 0-1000 scale
                    position = trackerPos / 100;
                }
                
                // Clamp to valid range
                position = Math.max(0, Math.min(0.99, position));
                carState.sector = sector;
                
                return position;
            }
            
            // Fallback: estimate from elapsed time
            const elapsedSec = (now - carState.lapStartTime) / 1000;
            
            const s1 = carState.sectorTimes[0];
            const s2 = carState.sectorTimes[1];
            const s3 = carState.sectorTimes[2];
            const totalLap = s1 + s2 + s3;
            
            let position;
            let sector;
            let status = 'normal';
            
            if (elapsedSec < s1) {
                sector = 1;
                position = (elapsedSec / s1) * 0.333;
            } else if (elapsedSec < s1 + s2) {
                sector = 2;
                position = 0.333 + ((elapsedSec - s1) / s2) * 0.333;
            } else if (elapsedSec < totalLap) {
                sector = 3;
                position = 0.666 + ((elapsedSec - s1 - s2) / s3) * 0.333;
            } else {
                sector = 3;
                position = 0.98;
                status = 'waiting';
            }
            
            carState.sector = sector;
            
            // Periodic logging - only log WAITING status
            if (now - carState.lastLogTime > trackAnimationState.logInterval) {
                carState.lastLogTime = now;
                if (status === 'waiting') {
                    trackLog(carNum, 'WAITING', `At S/F for ${(elapsedSec - totalLap).toFixed(1)}s`, {
                        elapsed: elapsedSec.toFixed(1) + 's',
                        expectedLap: totalLap.toFixed(1) + 's',
                        overtime: (elapsedSec - totalLap).toFixed(1) + 's'
                    });
                } else if (trackAnimationState.logPositions) {
                    trackLog(carNum, 'POSITION', `S${sector} pos=${(position*100).toFixed(1)}%`, {
                        elapsed: elapsedSec.toFixed(1) + 's',
                        sector: sector,
                        position: (position * 100).toFixed(1) + '%'
                    });
                }
            }
            
            return Math.max(0, Math.min(0.99, position));
        }
        
        // Animation loop - runs at ~30fps
        function animateTrackLoop() {
            if (!trackAnimationState.isRunning) return;
            
            // Render the track with current positions
            renderAnimatedTrackView();
            
            // Schedule next frame
            trackAnimationState.animationId = setTimeout(() => {
                requestAnimationFrame(animateTrackLoop);
            }, 33); // ~30fps
        }
        
        // Start track animation
        function startTrackAnimation() {
            if (trackAnimationState.isRunning) return;
            trackAnimationState.isRunning = true;
            
            // Initialize car states from current data
            rows.forEach(car => updateCarAnimationState(car));
            
            // Start the animation loop
            animateTrackLoop();
        }
        
        // Stop track animation
        function stopTrackAnimation() {
            trackAnimationState.isRunning = false;
            if (trackAnimationState.animationId) {
                clearTimeout(trackAnimationState.animationId);
                trackAnimationState.animationId = null;
            }
        }
        
        // Render the animated track view (called each frame)
        function renderAnimatedTrackView() {
            const graphEl = document.getElementById('trackModalGraph');
            if (!graphEl || graphEl.offsetParent === null) return;
            
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            if (sortedRows.length === 0) return;
            
            const filteredCars = getTrackModalFilteredCars();
            
            // Class colors
            const classColors = {
                'LMP2': '#0088ff', 'LMP3': '#9c27b0', 'LMP2 AM': '#ff9800',
                'HYPERCAR': '#ff2222', 'GT': '#00cc66', 'GT3': '#00cc66', 
                'GT4': '#8bc34a', 'TCR': '#cc44cc'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#3f51b5', '#009688', '#4caf50', '#cddc39', '#ff5722'];
            let colorIndex = 0;
            
            // Dimensions
            const width = graphEl.offsetWidth || 800;
            const height = graphEl.offsetHeight || 600;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(centerX, centerY) - 70;
            
            // Build SVG
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" style="font-family: 'Orbitron', sans-serif;">`;
            
            // Glow filter
            svg += `<defs><filter id="glow" x="-50%" y="-50%" width="200%" height="200%"><feGaussianBlur stdDeviation="4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>`;
            
            // Sector backgrounds
            const sectorColors = ['rgba(255,80,80,0.12)', 'rgba(80,255,80,0.12)', 'rgba(80,80,255,0.12)'];
            for (let i = 0; i < 3; i++) {
                const startAngle = -90 + i * 120;
                const endAngle = startAngle + 120;
                const startRad = startAngle * Math.PI / 180;
                const endRad = endAngle * Math.PI / 180;
                const x1 = centerX + (radius + 30) * Math.cos(startRad);
                const y1 = centerY + (radius + 30) * Math.sin(startRad);
                const x2 = centerX + (radius + 30) * Math.cos(endRad);
                const y2 = centerY + (radius + 30) * Math.sin(endRad);
                svg += `<path d="M ${centerX} ${centerY} L ${x1} ${y1} A ${radius + 30} ${radius + 30} 0 0 1 ${x2} ${y2} Z" fill="${sectorColors[i]}"/>`;
            }
            
            // Track ring
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="55"/>`;
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="none" stroke="rgba(0,255,100,0.06)" stroke-width="48"/>`;
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius - 25}" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="2"/>`;
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius + 25}" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="2"/>`;
            
            // Sector dividers and labels
            for (let i = 0; i < 3; i++) {
                const angle = (-90 + i * 120) * Math.PI / 180;
                const x1 = centerX + (radius - 35) * Math.cos(angle);
                const y1 = centerY + (radius - 35) * Math.sin(angle);
                const x2 = centerX + (radius + 35) * Math.cos(angle);
                const y2 = centerY + (radius + 35) * Math.sin(angle);
                svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(255,255,255,0.6)" stroke-width="3"/>`;
                
                const labelAngle = (-30 + i * 120) * Math.PI / 180;
                const labelX = centerX + (radius + 52) * Math.cos(labelAngle);
                const labelY = centerY + (radius + 52) * Math.sin(labelAngle);
                const sectorColor = i === 0 ? '#ff6666' : (i === 1 ? '#66ff66' : '#6666ff');
                svg += `<text x="${labelX}" y="${labelY}" fill="${sectorColor}" font-size="16" font-weight="bold" text-anchor="middle" dominant-baseline="middle">S${i + 1}</text>`;
            }
            
            // Start/Finish checkered line
            const sfY = centerY - radius;
            svg += `<rect x="${centerX - 15}" y="${sfY - 12}" width="30" height="14" fill="#fff"/>`;
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 5; col++) {
                    if ((row + col) % 2 === 0) {
                        svg += `<rect x="${centerX - 15 + col * 6}" y="${sfY - 12 + row * 7}" width="6" height="7" fill="#111"/>`;
                    }
                }
            }
            svg += `<text x="${centerX}" y="${sfY - 28}" fill="#fff" font-size="13" font-weight="bold" text-anchor="middle">START / FINISH</text>`;
            
            const classesUsed = new Set();
            let carsOnTrack = 0;
            let carsInPit = 0;
            const pitCars = [];
            
            // Update and render each car
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                const carClass = car.class || car.col_9 || 'Unknown';
                const pos = car.position || car.col_0 || '?';
                
                if (filteredCars && !filteredCars.includes(carNum)) return;
                
                classesUsed.add(carClass);
                
                // Update animation state and calculate current position
                const carState = updateCarAnimationState(car);
                const trackPosition = calculateCarTrackPosition(carState, carNum);
                
                // Get color
                let color = classColors[carClass];
                if (!color) {
                    color = defaultColors[colorIndex % defaultColors.length];
                    classColors[carClass] = color;
                    colorIndex++;
                }
                
                const hasUpdate = isRecentlyUpdated(carNum);
                const isTracked = carNum === trackedCarNumber;
                
                if (carState.inPit || trackPosition === null) {
                    carsInPit++;
                    pitCars.push({ carNum, color, pos, carClass, isTracked, hasUpdate });
                    return;
                }
                
                carsOnTrack++;
                
                // Convert position (0-1) to angle: 0 = top (-90¬∞), clockwise
                const angle = (-90 + trackPosition * 360) * Math.PI / 180;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const size = isTracked ? 26 : (index < 3 ? 22 : 18);
                
                const strokeColor = isTracked ? 'var(--accent-green)' : (hasUpdate ? '#00ff88' : 'rgba(255,255,255,0.5)');
                const strokeWidth = isTracked || hasUpdate ? 3 : 2;
                const filter = isTracked ? 'filter="url(#glow)"' : '';
                
                // Tracked car animated ring
                const trackedRing = isTracked ? `
                    <circle cx="${x}" cy="${y}" r="${size + 12}" fill="none" stroke="var(--accent-green)" stroke-width="2" stroke-dasharray="8,4" opacity="0.8">
                        <animateTransform attributeName="transform" type="rotate" from="0 ${x} ${y}" to="360 ${x} ${y}" dur="3s" repeatCount="indefinite"/>
                    </circle>
                ` : '';
                
                svg += `
                    <g onclick="trackCar('${carNum}'); updateTrackInfoPanel('${carNum}');" style="cursor: pointer;" ${filter}>
                        ${trackedRing}
                        <circle cx="${x}" cy="${y}" r="${size + 4}" fill="rgba(0,0,0,0.7)"/>
                        <circle cx="${x}" cy="${y}" r="${size}" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        <text x="${x}" y="${y + 1}" fill="#fff" font-size="${isTracked ? 12 : 10}" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${carNum}</text>
                    </g>
                `;
                
                // Position badges for P1-P3 and tracked
                if (index < 3 || isTracked) {
                    const badgeColor = index === 0 ? '#ffd700' : (index === 1 ? '#c0c0c0' : (index === 2 ? '#cd7f32' : 'var(--accent-green)'));
                    const badgeAngle = Math.atan2(y - centerY, x - centerX);
                    const badgeX = x + (size + 20) * Math.cos(badgeAngle);
                    const badgeY = y + (size + 20) * Math.sin(badgeAngle);
                    svg += `<text x="${badgeX}" y="${badgeY}" fill="${badgeColor}" font-size="12" font-weight="bold" text-anchor="middle" dominant-baseline="middle" style="text-shadow: 0 2px 4px rgba(0,0,0,0.9);">P${pos}</text>`;
                }
            });
            
            // Render pit cars in center
            if (pitCars.length > 0) {
                const pitRadius = radius * 0.35;
                svg += `<circle cx="${centerX}" cy="${centerY}" r="${pitRadius + 20}" fill="rgba(255,200,0,0.05)" stroke="rgba(255,200,0,0.3)" stroke-width="2" stroke-dasharray="10,5"/>`;
                
                pitCars.forEach((pc, i) => {
                    const pitAngle = (-90 + (i / pitCars.length) * 360) * Math.PI / 180;
                    const px = centerX + pitRadius * 0.6 * Math.cos(pitAngle);
                    const py = centerY + pitRadius * 0.6 * Math.sin(pitAngle);
                    const psize = pc.isTracked ? 20 : 14;
                    
                    svg += `
                        <g onclick="trackCar('${pc.carNum}'); updateTrackInfoPanel('${pc.carNum}');" style="cursor: pointer; opacity: 0.7;">
                            <circle cx="${px}" cy="${py}" r="${psize + 2}" fill="rgba(0,0,0,0.6)"/>
                            <circle cx="${px}" cy="${py}" r="${psize}" fill="${pc.color}" stroke="#ffcc00" stroke-width="2"/>
                            <text x="${px}" y="${py + 1}" fill="#fff" font-size="9" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${pc.carNum}</text>
                        </g>
                    `;
                });
            }
            
            // Pit label
            svg += `<text x="${centerX}" y="${centerY - 12}" fill="rgba(255,200,0,0.9)" font-size="18" font-weight="bold" text-anchor="middle">PIT</text>`;
            svg += `<text x="${centerX}" y="${centerY + 14}" fill="rgba(255,200,0,1)" font-size="28" font-weight="bold" text-anchor="middle">${carsInPit}</text>`;
            
            // Live clock
            const now = new Date();
            const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            svg += `
                <g>
                    <circle cx="25" cy="25" r="6" fill="#00ff88"><animate attributeName="opacity" values="1;0.3;1" dur="1s" repeatCount="indefinite"/></circle>
                    <text x="38" y="29" fill="#00ff88" font-size="12" font-weight="bold">LIVE</text>
                    <text x="${width - 15}" y="29" fill="rgba(255,255,255,0.6)" font-size="13" text-anchor="end" font-family="'Roboto Mono', monospace">${timeStr}</text>
                </g>
            `;
            
            svg += '</svg>';
            graphEl.innerHTML = svg;
            
            // Update legend (throttled)
            updateTrackModalLegend(classesUsed, classColors, carsOnTrack, carsInPit, sortedRows.length, filteredCars);
        }
        
        // Update track legend (once per second max)
        let lastTrackLegendUpdate = 0;
        function updateTrackModalLegend(classesUsed, classColors, onTrack, inPit, total, filtered) {
            const now = Date.now();
            if (now - lastTrackLegendUpdate < 1000) return;
            lastTrackLegendUpdate = now;
            
            const legendEl = document.getElementById('trackModalLegend');
            if (!legendEl) return;
            
            let html = '';
            classesUsed.forEach(cls => {
                const color = classColors[cls] || '#888';
                html += `<div style="display: flex; align-items: center; gap: 6px;"><div style="width: 14px; height: 14px; border-radius: 50%; background: ${color}; border: 2px solid rgba(255,255,255,0.3);"></div><span style="font-size: 12px; color: var(--text-secondary);">${cls}</span></div>`;
            });
            
            html += `<div style="padding-left: 15px; border-left: 1px solid var(--border-color);"><span style="font-size: 12px; color: var(--accent-green);">Track: <strong>${onTrack}</strong></span></div>`;
            html += `<div style="padding-left: 15px; border-left: 1px solid var(--border-color);"><span style="font-size: 12px; color: #ffcc00;">Pit: <strong>${inPit}</strong></span></div>`;
            html += `<div style="padding-left: 15px; border-left: 1px solid var(--border-color);"><span style="font-size: 12px; color: var(--text-muted);">Total: <strong>${onTrack + inPit}</strong>/${total}</span></div>`;
            if (filtered) html += `<div style="padding-left: 15px; border-left: 1px solid var(--border-color);"><span style="font-size: 12px; color: var(--accent-cyan);">Filtered</span></div>`;
            
            legendEl.innerHTML = html;
        }
        
        // Update info panel when clicking a car
        function updateTrackInfoPanel(carNum) {
            const infoPanel = document.getElementById('trackModalInfo');
            if (!infoPanel) return;
            
            const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
            if (!car) return;
            
            const carState = trackAnimationState.cars.get(carNum);
            const pos = car.position || car.col_0 || '?';
            const name = car.name || car.currentdriver || car.col_4 || '';
            const team = car.car || car.team || car.col_5 || '';
            const carClass = car.class || car.col_9 || '';
            const laps = car.laps || car.col_10 || '-';
            const lastLap = car.lastroundtime || car.col_13;
            const bestLap = car.fastestroundtime || car.col_14;
            const gap = car.hole || car.diff || car.col_11 || car.col_12 || '';
            
            const lastLapFormatted = lastLap ? formatTime(parseInt(lastLap)) : '-';
            const bestLapFormatted = bestLap ? formatTime(parseInt(bestLap)) : '-';
            
            // Get sector times from car state (sectorTimes are in seconds)
            const s1 = carState?.sectorTimes?.[0] ? carState.sectorTimes[0].toFixed(3) : '-';
            const s2 = carState?.sectorTimes?.[1] ? carState.sectorTimes[1].toFixed(3) : '-';
            const s3 = carState?.sectorTimes?.[2] ? carState.sectorTimes[2].toFixed(3) : '-';
            const currentSector = carState?.sector || 1;
            const trackPos = carState ? calculateCarTrackPosition(carState, carNum) || 0 : 0;
            
            infoPanel.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 52px; font-weight: bold; color: var(--accent-cyan);">#${carNum}</div>
                    <div style="font-size: 16px; color: var(--text-muted); margin-top: 5px;">Position <span style="color: ${parseInt(pos) <= 3 ? '#ffd700' : 'var(--text-bright)'}; font-weight: bold;">${pos}</span> ‚Ä¢ Lap ${laps}</div>
                </div>
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 18px; font-weight: 600; color: var(--text-bright);">${name || 'Unknown Driver'}</div>
                    <div style="font-size: 14px; color: var(--text-secondary); margin-top: 4px;">${team}</div>
                    <div style="display: inline-block; padding: 5px 12px; background: var(--bg-primary); border-radius: 4px; margin-top: 10px; font-size: 13px; color: var(--text-secondary); font-weight: 600;">${carClass}</div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                        <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">Last Lap</div>
                        <div style="font-family: 'Roboto Mono', monospace; font-size: 20px; color: var(--text-bright); margin-top: 6px;">${lastLapFormatted}</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px;">
                        <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">Best Lap</div>
                        <div style="font-family: 'Roboto Mono', monospace; font-size: 20px; color: var(--color-best-personal); margin-top: 6px;">${bestLapFormatted}</div>
                    </div>
                </div>
                <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">Gap to Leader</div>
                    <div style="font-family: 'Roboto Mono', monospace; font-size: 22px; color: var(--color-gap); margin-top: 6px;">${gap || 'LEADER'}</div>
                </div>
                <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px;">Sector Times</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; text-align: center;">
                        <div style="padding: 8px; background: ${currentSector === 1 ? 'rgba(255,100,100,0.3)' : 'var(--bg-tertiary)'}; border-radius: 4px; border: 1px solid ${currentSector === 1 ? '#ff6666' : 'transparent'};"><div style="font-size: 9px; color: #ff6666;">S1</div><div style="font-family: 'Roboto Mono', monospace; font-size: 13px; color: var(--text-bright);">${s1}</div></div>
                        <div style="padding: 8px; background: ${currentSector === 2 ? 'rgba(100,255,100,0.3)' : 'var(--bg-tertiary)'}; border-radius: 4px; border: 1px solid ${currentSector === 2 ? '#66ff66' : 'transparent'};"><div style="font-size: 9px; color: #66ff66;">S2</div><div style="font-family: 'Roboto Mono', monospace; font-size: 13px; color: var(--text-bright);">${s2}</div></div>
                        <div style="padding: 8px; background: ${currentSector === 3 ? 'rgba(100,100,255,0.3)' : 'var(--bg-tertiary)'}; border-radius: 4px; border: 1px solid ${currentSector === 3 ? '#6666ff' : 'transparent'};"><div style="font-size: 9px; color: #6666ff;">S3</div><div style="font-family: 'Roboto Mono', monospace; font-size: 13px; color: var(--text-bright);">${s3}</div></div>
                    </div>
                </div>
                ${carState ? `
                <div style="background: var(--bg-primary); padding: 14px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">Track Position</div>
                    <div style="display: flex; align-items: center; gap: 12px; margin-top: 10px;">
                        <div style="flex: 1; height: 10px; background: var(--bg-tertiary); border-radius: 5px; overflow: hidden; position: relative;">
                            <div style="position: absolute; width: 33.3%; height: 100%; left: 0; background: rgba(255,100,100,0.2);"></div>
                            <div style="position: absolute; width: 33.3%; height: 100%; left: 33.3%; background: rgba(100,255,100,0.2);"></div>
                            <div style="position: absolute; width: 33.4%; height: 100%; left: 66.6%; background: rgba(100,100,255,0.2);"></div>
                            <div style="position: absolute; width: 8px; height: 100%; left: ${(trackPos * 100).toFixed(1)}%; background: var(--accent-cyan); border-radius: 4px; transform: translateX(-50%); box-shadow: 0 0 6px var(--accent-cyan);"></div>
                        </div>
                        <span style="font-size: 14px; color: var(--text-secondary); font-weight: bold;">S${currentSector}</span>
                    </div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 10px; text-align: center;">
                        ${carState.inPit ? 'üîß <span style="color: #ffcc00;">IN PIT</span>' : 'üèéÔ∏è <span style="color: #00ff88;">ON TRACK</span>'}
                        ‚Ä¢ Pace: ${carState.sectorTimes[carState.sector - 1].toFixed(2)}s
                    </div>
                </div>
                ` : ''}
                <button onclick="trackCar('${carNum}'); closeTrackFullscreen();" style="width: 100%; padding: 14px; background: linear-gradient(135deg, var(--accent-green), #00cc66); color: #000; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: bold; cursor: pointer;">TRACK THIS CAR</button>
                <button onclick="openStintAnalysis('${carNum}'); closeTrackFullscreen();" style="width: 100%; margin-top: 8px; padding: 12px; background: var(--accent-purple); color: #fff; border: none; border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: bold; cursor: pointer;">‚è±Ô∏è STINT ANALYSIS</button>
            `;
        }
        
        // Legacy wrapper
        function renderFullscreenTrack(sortedRows) {
            sortedRows.forEach(car => updateCarAnimationState(car));
            startTrackAnimation();
        }
        
        // ===========================================
        // STINT ANALYSIS
        // ===========================================
        const stintData = new Map(); // carNum -> { stints: [], currentStint: {} }
        
        function initStintTracking(carNum) {
            if (!stintData.has(carNum)) {
                stintData.set(carNum, {
                    stints: [],
                    currentStint: { driver: null, startLap: 0, laps: [], pitCount: 0 }
                });
            }
            return stintData.get(carNum);
        }
        
        function updateStintTracking(car) {
            const carNum = car.startnumber || car.col_2;
            if (!carNum) return;
            
            const data = initStintTracking(carNum);
            const currentDriver = car.currentdriver || car.col_7 || '';
            const currentLap = parseInt(car.laps || car.col_10 || '0');
            const pitCount = parseInt(car.pitstops || car.col_15 || '0');
            
            // Detect stint change
            const driverChanged = data.currentStint.driver && currentDriver && data.currentStint.driver !== currentDriver;
            const newPitStop = data.currentStint.pitCount !== undefined && pitCount > data.currentStint.pitCount;
            
            if ((driverChanged || newPitStop) && data.currentStint.laps.length > 0) {
                data.stints.push({...data.currentStint});
                data.currentStint = { driver: currentDriver, startLap: currentLap, laps: [], pitCount: pitCount };
            }
            
            if (!data.currentStint.driver) {
                data.currentStint.driver = currentDriver;
                data.currentStint.startLap = Math.max(1, currentLap);
                data.currentStint.pitCount = pitCount;
            }
            
            // Track lap times
            const lastLapTime = car.lastroundtime || car.col_13;
            if (lastLapTime && currentLap > 0) {
                const lapTimeNum = parseInt(lastLapTime);
                if (!isNaN(lapTimeNum) && lapTimeNum > 30000000 && lapTimeNum < 600000000) {
                    if (!data.currentStint.laps.find(l => l.lap === currentLap)) {
                        // Validate sector times (5-300 seconds in microseconds)
                        const s1Raw = parseInt(car.sectortimes_1 || car.col_16);
                        const s2Raw = parseInt(car.sectortimes_2 || car.col_17);
                        const s3Raw = parseInt(car.sectortimes_3 || car.col_18);
                        const validSector = (v) => v > 5000000 && v < 300000000;
                        
                        data.currentStint.laps.push({
                            lap: currentLap,
                            time: lapTimeNum,
                            s1: validSector(s1Raw) ? s1Raw : null,
                            s2: validSector(s2Raw) ? s2Raw : null,
                            s3: validSector(s3Raw) ? s3Raw : null
                        });
                    }
                }
            }
        }
        
        function calculateStintStats(stint) {
            const laps = stint.laps.filter(l => l.time && l.time > 30000000);
            if (laps.length === 0) return { lapCount: 0 };
            
            const times = laps.map(l => l.time);
            const sortedTimes = [...times].sort((a, b) => a - b);
            const bestTime = Math.min(...times);
            const bestLapEntry = laps.find(l => l.time === bestTime);
            const sum = times.reduce((a, b) => a + b, 0);
            const average = sum / times.length;
            const mid = Math.floor(sortedTimes.length / 2);
            const median = sortedTimes.length % 2 === 0 ? (sortedTimes[mid - 1] + sortedTimes[mid]) / 2 : sortedTimes[mid];
            const squaredDiffs = times.map(t => Math.pow(t - average, 2));
            const stdDev = Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / times.length);
            const consistency = 100 - Math.min(100, (stdDev / average) * 1000);
            
            return { lapCount: laps.length, duration: sum, bestLap: bestTime, bestLapNum: bestLapEntry?.lap, average, median, stdDev, consistency, laps };
        }
        
        function openStintAnalysis(carNum) {
            document.getElementById('stintAnalysisModal').classList.remove('hidden');
            const select = document.getElementById('stintCarSelect');
            select.innerHTML = '';
            
            [...rows].sort((a, b) => parseInt(a.position || a.col_0 || '999') - parseInt(b.position || b.col_0 || '999'))
                .forEach(car => {
                    const num = car.startnumber || car.col_2;
                    const pos = car.position || car.col_0 || '?';
                    const option = document.createElement('option');
                    option.value = num;
                    option.textContent = `#${num} - P${pos}`;
                    if (num === carNum) option.selected = true;
                    select.appendChild(option);
                });
            renderStintAnalysis();
        }
        
        function closeStintAnalysis() {
            document.getElementById('stintAnalysisModal').classList.add('hidden');
        }
        
        function renderStintAnalysis() {
            const carNum = document.getElementById('stintCarSelect')?.value;
            if (!carNum) return;
            
            const car = rows.find(r => (r.startnumber || r.col_2) === carNum);
            if (!car) return;
            
            updateStintTracking(car);
            const data = stintData.get(carNum);
            if (!data) return;
            
            // Update info bar
            const infoBar = document.getElementById('stintCarInfo');
            infoBar.innerHTML = `
                <div style="font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: bold; color: var(--accent-cyan);">#${carNum}</div>
                <div><div style="font-size: 14px; font-weight: 600; color: var(--text-bright);">${car.name || car.currentdriver || car.col_4 || ''}</div></div>
                <div style="padding: 4px 10px; background: var(--bg-tertiary); border-radius: 4px; font-size: 12px;">${car.class || car.col_9 || ''}</div>
                <div style="font-size: 12px; color: var(--text-muted);">Laps: ${car.laps || car.col_10 || '0'} | Pits: ${car.pitstops || car.col_15 || '0'}</div>
            `;
            
            const allStints = [...data.stints];
            if (data.currentStint.laps.length > 0) allStints.push({...data.currentStint, isCurrent: true});
            
            const content = document.getElementById('stintAnalysisContent');
            if (allStints.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-muted);"><div style="font-size: 48px;">üìä</div><div>No stint data yet</div></div>';
                return;
            }
            
            const stintStats = allStints.map(s => ({...s, stats: calculateStintStats(s)}));
            
            let html = `<table style="width: 100%; border-collapse: collapse; font-size: 14px; margin-bottom: 30px;">
                <thead><tr style="background: var(--bg-tertiary);">
                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">METRIC</th>
                    ${stintStats.map((s, i) => `<th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border-color); min-width: 130px;"><div style="color: ${s.isCurrent ? 'var(--accent-green)' : 'var(--accent-cyan)'}; font-weight: bold;">STINT ${i + 1}</div><div style="font-size: 11px; color: var(--text-muted);">${s.driver || ''}</div></th>`).join('')}
                </tr></thead>
                <tbody>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">DURATION</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color);"><div style="font-size: 18px; font-weight: bold;">${s.stats.lapCount} laps</div><div style="font-size: 12px; color: var(--text-muted);">${s.stats.duration ? formatTime(s.stats.duration) : '-'}</div></td>`).join('')}</tr>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">BEST LAP</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color);"><div style="font-family: 'Roboto Mono', monospace; font-size: 16px; color: var(--color-best-personal);">${s.stats.bestLap ? formatTime(s.stats.bestLap) : '-'}</div><div style="font-size: 11px; color: var(--text-muted);">Lap ${s.stats.bestLapNum || '-'}</div></td>`).join('')}</tr>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">AVERAGE</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color); font-family: 'Roboto Mono', monospace;">${s.stats.average ? formatTime(s.stats.average) : '-'}</td>`).join('')}</tr>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">MEDIAN</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color); font-family: 'Roboto Mono', monospace;">${s.stats.median ? formatTime(s.stats.median) : '-'}</td>`).join('')}</tr>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">STD DEV</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color); font-family: 'Roboto Mono', monospace;">${s.stats.stdDev ? (s.stats.stdDev / 1000000).toFixed(3) + 's' : '-'}</td>`).join('')}</tr>
                    <tr><td style="padding: 12px; border-bottom: 1px solid var(--border-color);">CONSISTENCY</td>
                    ${stintStats.map(s => `<td style="padding: 12px; text-align: center; border-bottom: 1px solid var(--border-color);"><div style="width: 80%; height: 8px; background: var(--bg-primary); border-radius: 4px; margin: 0 auto 6px;"><div style="width: ${s.stats.consistency || 0}%; height: 100%; background: ${s.stats.consistency >= 95 ? 'var(--accent-green)' : s.stats.consistency >= 90 ? 'var(--accent-cyan)' : 'var(--accent-yellow)'}; border-radius: 4px;"></div></div><span style="font-weight: bold;">${s.stats.consistency ? s.stats.consistency.toFixed(1) + '%' : '-'}</span></td>`).join('')}</tr>
                </tbody>
            </table>`;
            
            content.innerHTML = html;
        }
        
        function getGraphFilteredCars() {
            const input = document.getElementById('graphCarFilter');
            if (!input || !input.value.trim()) return null;
            
            // Parse comma-separated car numbers
            const numbers = input.value.split(',')
                .map(n => n.trim())
                .filter(n => n.length > 0);
            
            return numbers.length > 0 ? numbers : null;
        }
        
        // Update position graph (called from main update loop)
        function updatePositionGraph() {
            if (rows.length === 0) return;
            
            // Sort rows by position
            const sortedRows = [...rows].sort((a, b) => {
                const posA = parseInt(a.position || a.col_0 || '999', 10);
                const posB = parseInt(b.position || b.col_0 || '999', 10);
                return posA - posB;
            });
            
            // Record positions for lap chart
            recordPositions(sortedRows);
            
            if (graphViewMode === 'linear') {
                renderLinearGraph(sortedRows);
            } else if (graphViewMode === 'circular') {
                renderCircularGraph(sortedRows);
            } else if (graphViewMode === 'lapchart') {
                renderLapChart(sortedRows);
            }
        }
        
        // Record positions for each car at each lap
        function recordPositions(sortedRows) {
            if (sortedRows.length === 0) return;
            
            // Get current lap from heatState (more reliable than parsing car data)
            const currentLap = heatState.leaderLap || 0;
            if (currentLap <= 0) return;
            
            // Record initial state if we have no history yet
            const hasHistory = Object.keys(positionHistory).length > 0;
            
            // Record when: first time, or lap changed
            if (!hasHistory || currentLap !== lastRecordedLap) {
                lastRecordedLap = currentLap;
                Store.lastRecordedLap = currentLap;
                
                // Record each car's position at this lap
                sortedRows.forEach(row => {
                    const carNum = row.startnumber || row.col_2;
                    if (!carNum) return;
                    
                    const pos = parseInt(row.position || row.col_0 || '999', 10);
                    const carLap = calculateActualLap(row) || currentLap;
                    
                    // Legacy positionHistory
                    if (!positionHistory[carNum]) {
                        positionHistory[carNum] = [];
                    }
                    
                    // Only add if we don't already have this lap recorded
                    const existing = positionHistory[carNum].find(p => p.lap === currentLap);
                    if (!existing && pos < 900) {
                        const posEntry = { lap: currentLap, pos: pos, carLap: carLap };
                        pushCapped(positionHistory[carNum], posEntry, MAX_HISTORY);
                        
                        // Also update Store.cars
                        const car = getCar(carNum);
                        car.pos = pos;
                        car.lap = carLap;
                        pushCapped(car.history.positions, posEntry, MAX_HISTORY);
                    }
                });
                
                // Also store in Store.positionHistory
                Store.positionHistory = positionHistory;
                
                console.log(`[LapChart] Recorded positions for lap ${currentLap}, ${Object.keys(positionHistory).length} cars`);
            }
        }
        
        // Render lap chart showing position changes over laps
        function renderLapChart(sortedRows) {
            const graphEl = document.getElementById('positionGraphLapChart');
            const legendEl = document.getElementById('positionGraphLegend');
            
            if (!graphEl) return;
            
            // Get filter
            const filteredCars = getGraphFilteredCars();
            
            // Class colors
            const classColors = {
                'LMP2': '#0088ff',
                'LMP3': '#9c27b0',
                'LMP2 AM': '#ff9800',
                'GT': '#e91e63',
                'GT3': '#e91e63',
                'GT4': '#8bc34a'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#3f51b5', '#009688', '#4caf50', '#cddc39', '#ff5722', '#795548'];
            let colorIndex = 0;
            
            // Find max lap and max position
            let maxLap = 0;
            let minLap = 999999;
            let maxPos = 0;
            Object.values(positionHistory).forEach(history => {
                history.forEach(h => {
                    if (h.lap > maxLap) maxLap = h.lap;
                    if (h.lap < minLap) minLap = h.lap;
                    if (h.pos > maxPos) maxPos = h.pos;
                });
            });
            
            // Also get current positions if no history yet
            if (maxLap === 0 && sortedRows.length > 0) {
                const leader = sortedRows[0];
                maxLap = parseInt(leader.numberoflapscomplete || leader.col_3 || '0', 10);
                minLap = maxLap;
                maxPos = sortedRows.length;
            }
            
            if (maxLap === 0 && Object.keys(positionHistory).length === 0) {
                graphEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">Waiting for lap data... (positions recorded each lap)</div>';
                return;
            }
            
            // Ensure we have reasonable bounds
            if (maxPos < 1) maxPos = sortedRows.length || 20;
            if (minLap === 999999) minLap = maxLap;
            
            // Container dimensions
            const width = graphEl.offsetWidth || 600;
            const height = 300;
            const padding = { top: 20, right: 30, bottom: 30, left: 40 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Calculate how many laps to show (last 30 laps or all if less)
            const lapsToShow = Math.max(1, Math.min(30, maxLap - minLap + 1));
            const startLap = Math.max(minLap, maxLap - lapsToShow + 1);
            const lapRange = Math.max(1, maxLap - startLap);
            
            // Build SVG
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" style="font-family: 'Orbitron', sans-serif;">`;
            
            // Background grid
            // Horizontal lines (positions)
            const posStep = maxPos > 20 ? 5 : (maxPos > 10 ? 2 : 1);
            for (let p = 1; p <= maxPos; p += posStep) {
                const y = padding.top + ((p - 1) / Math.max(1, maxPos - 1)) * chartHeight;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>`;
                svg += `<text x="${padding.left - 5}" y="${y + 4}" fill="rgba(255,255,255,0.4)" font-size="9" text-anchor="end">P${p}</text>`;
            }
            
            // Vertical lines (laps)
            const lapStep = Math.max(1, Math.ceil(lapsToShow / 10));
            for (let l = startLap; l <= maxLap; l += lapStep) {
                const x = padding.left + ((l - startLap) / Math.max(1, lapRange)) * chartWidth;
                svg += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>`;
                svg += `<text x="${x}" y="${height - padding.bottom + 15}" fill="rgba(255,255,255,0.4)" font-size="9" text-anchor="middle">L${l}</text>`;
            }
            
            // Draw position lines for each car
            const classesUsed = new Set();
            
            sortedRows.forEach(car => {
                const carNum = car.startnumber || car.col_2;
                if (!carNum) return;
                
                // Check filter
                if (filteredCars && !filteredCars.includes(carNum)) return;
                
                const history = positionHistory[carNum] || [];
                const carClass = car.class || car.col_9 || 'Unknown';
                classesUsed.add(carClass);
                
                // Get color
                let color = classColors[carClass];
                if (!color) {
                    color = defaultColors[colorIndex % defaultColors.length];
                    classColors[carClass] = color;
                    colorIndex++;
                }
                
                const isTracked = carNum === trackedCarNumber;
                const strokeWidth = isTracked ? 3 : 1.5;
                const opacity = isTracked ? 1 : 0.7;
                
                // Build path from history
                let pathData = '';
                let lastX = 0, lastY = 0;
                
                history.forEach((h, i) => {
                    if (h.lap < startLap) return;
                    
                    const x = padding.left + ((h.lap - startLap) / Math.max(1, lapRange)) * chartWidth;
                    const y = padding.top + ((h.pos - 1) / Math.max(1, maxPos - 1)) * chartHeight;
                    
                    if (pathData === '') {
                        pathData = `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                    lastX = x;
                    lastY = y;
                });
                
                // Draw path if we have history
                if (pathData) {
                    svg += `<path d="${pathData}" fill="none" stroke="${color}" stroke-width="${strokeWidth}" opacity="${opacity}" stroke-linejoin="round"/>`;
                }
                
                // Draw current position dot (use current position if no history)
                const currentPos = parseInt(car.position || car.col_0 || '999', 10);
                let dotX, dotY;
                
                if (history.length > 0) {
                    const lastPoint = history[history.length - 1];
                    dotX = padding.left + ((lastPoint.lap - startLap) / Math.max(1, lapRange)) * chartWidth;
                    dotY = padding.top + ((lastPoint.pos - 1) / Math.max(1, maxPos - 1)) * chartHeight;
                } else {
                    // No history, show current position at current lap
                    dotX = padding.left + chartWidth;
                    dotY = padding.top + ((currentPos - 1) / Math.max(1, maxPos - 1)) * chartHeight;
                }
                
                const dotSize = isTracked ? 6 : 4;
                
                svg += `
                    <g onclick="trackCar('${carNum}')" style="cursor: pointer;" class="lap-chart-dot">
                        <circle cx="${dotX}" cy="${dotY}" r="${dotSize + 2}" fill="rgba(0,0,0,0.5)"/>
                        <circle cx="${dotX}" cy="${dotY}" r="${dotSize}" fill="${color}" stroke="${isTracked ? 'var(--accent-green)' : '#fff'}" stroke-width="${isTracked ? 2 : 1}"/>
                        <title>#${carNum} - P${currentPos}</title>
                    </g>
                `;
                
                // Label for tracked or top cars
                if (isTracked || currentPos <= 3) {
                    svg += `<text x="${dotX + 8}" y="${dotY + 3}" fill="${color}" font-size="8" font-weight="bold">#${carNum}</text>`;
                }
            });
            
            // Axis labels
            svg += `<text x="${width / 2}" y="${height - 5}" fill="rgba(255,255,255,0.5)" font-size="10" text-anchor="middle">LAP</text>`;
            svg += `<text x="12" y="${height / 2}" fill="rgba(255,255,255,0.5)" font-size="10" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})">POSITION</text>`;
            
            svg += '</svg>';
            
            graphEl.innerHTML = svg;
            
            // Render legend
            let legendHtml = '';
            classesUsed.forEach(cls => {
                const color = classColors[cls] || '#888';
                legendHtml += `
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div style="width: 10px; height: 10px; border-radius: 50%; background: ${color};"></div>
                        <span style="font-size: 10px; color: var(--text-secondary);">${cls}</span>
                    </div>
                `;
            });
            
            const historyCount = Object.keys(positionHistory).length;
            legendHtml += `
                <div style="padding-left: 8px; border-left: 1px solid var(--border-color);">
                    <span style="font-size: 10px; color: var(--text-muted);">Lap ${startLap}-${maxLap} | ${historyCount > 0 ? historyCount + ' cars tracked' : 'Recording...'}</span>
                </div>
            `;
            
            if (filteredCars) {
                legendHtml += `
                    <div style="padding-left: 8px; border-left: 1px solid var(--border-color);">
                        <span style="font-size: 10px; color: var(--accent-yellow);">Filtered: ${filteredCars.length} cars</span>
                    </div>
                `;
            }
            
            if (legendEl) legendEl.innerHTML = legendHtml;
        }
        
        // Render the linear position graph with class-based lanes
        function renderLinearGraph(sortedRows) {
            const graphEl = document.getElementById('positionGraphLinear');
            const legendEl = document.getElementById('positionGraphLegend');
            
            if (!graphEl || sortedRows.length === 0) return;
            
            // Get filter
            const filteredCars = getGraphFilteredCars();
            
            // Filter rows if needed
            let displayRows = sortedRows;
            if (filteredCars) {
                displayRows = sortedRows.filter(car => {
                    const carNum = car.startnumber || car.col_2 || '';
                    return filteredCars.includes(carNum);
                });
            }
            
            if (displayRows.length === 0) {
                graphEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">No matching cars found</div>';
                return;
            }
            
            // Build class colors and detect unique classes
            const classColors = {
                'LMP2': '#0088ff',
                'LMP3': '#9933cc',
                'LMP2 AM': '#ff8800',
                'HYPERCAR': '#ff2222',
                'GT': '#00cc66',
                'GT3': '#00cc66',
                'GT4': '#88cc22',
                'TCR': '#cc44cc'
            };
            const defaultColors = ['#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#00bcd4', '#009688', '#4caf50'];
            let colorIndex = 0;
            
            // Get unique classes in order of first appearance
            const classOrder = [];
            const classCars = {};
            sortedRows.forEach(car => {
                const carClass = car.class || car.col_9 || 'Unknown';
                if (!classOrder.includes(carClass)) {
                    classOrder.push(carClass);
                    classCars[carClass] = [];
                }
                classCars[carClass].push(car);
            });
            
            // Assign colors to classes
            classOrder.forEach(cls => {
                if (!classColors[cls]) {
                    classColors[cls] = defaultColors[colorIndex % defaultColors.length];
                    colorIndex++;
                }
            });
            
            // Calculate cumulative gaps from leader
            let cumulativeGaps = {};
            let maxGap = 0;
            
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                if (index === 0) {
                    cumulativeGaps[carNum] = 0;
                } else {
                    const gapStr = car.diff || car.col_12 || '0';
                    let gapSeconds = parseGapToSeconds(gapStr);
                    if (gapSeconds === null) gapSeconds = 120;
                    
                    const prevCar = sortedRows[index - 1];
                    const prevCarNum = prevCar.startnumber || prevCar.col_2 || '?';
                    const prevGap = cumulativeGaps[prevCarNum] || 0;
                    cumulativeGaps[carNum] = prevGap + gapSeconds;
                    maxGap = Math.max(maxGap, cumulativeGaps[carNum]);
                }
            });
            
            // If max gap is 0 or very small, use positions for spacing
            const useTimeGaps = maxGap >= 1;
            if (!useTimeGaps) {
                maxGap = sortedRows.length;
                sortedRows.forEach((car, index) => {
                    const carNum = car.startnumber || car.col_2 || '?';
                    cumulativeGaps[carNum] = index;
                });
            }
            
            // Calculate lane positions (distribute classes vertically)
            const numLanes = classOrder.length;
            const laneHeight = 100 / Math.max(numLanes, 1);
            const classLanes = {};
            classOrder.forEach((cls, idx) => {
                classLanes[cls] = (idx + 0.5) * laneHeight; // Center of each lane as percentage
            });
            
            // Start building graph HTML
            let graphHtml = '';
            
            // Draw lane backgrounds and class labels
            classOrder.forEach((cls, idx) => {
                const laneTop = idx * laneHeight;
                const color = classColors[cls];
                const isEven = idx % 2 === 0;
                
                // Lane background (alternating)
                graphHtml += `
                    <div style="position: absolute; top: ${laneTop}%; left: 0; right: 0; height: ${laneHeight}%; 
                                background: ${isEven ? 'rgba(255,255,255,0.02)' : 'transparent'}; 
                                border-bottom: 1px solid var(--border-subtle);"></div>
                `;
                
                // Class label on left
                graphHtml += `
                    <div style="position: absolute; top: ${laneTop}%; left: 4px; height: ${laneHeight}%; 
                                display: flex; align-items: center; z-index: 10;">
                        <span style="font-size: 9px; font-weight: 700; color: ${color}; 
                                     text-shadow: 0 1px 2px rgba(0,0,0,0.8); letter-spacing: 0.5px;
                                     writing-mode: horizontal-tb; white-space: nowrap;">
                            ${cls.length > 8 ? cls.substring(0, 8) : cls}
                        </span>
                    </div>
                `;
                
                // Lane track line
                graphHtml += `
                    <div style="position: absolute; top: ${classLanes[cls]}%; left: 50px; right: 20px; 
                                height: 2px; background: ${color}40; transform: translateY(-50%);"></div>
                `;
            });
            
            // Finish line (P1 marker on right)
            graphHtml += `
                <div style="position: absolute; top: 5px; bottom: 5px; right: 14px; width: 3px; 
                            background: repeating-linear-gradient(0deg, #fff 0px, #fff 3px, #333 3px, #333 6px); 
                            border-radius: 1px;"></div>
            `;
            
            // Add time scale markers if using time gaps
            if (useTimeGaps && maxGap > 5) {
                const interval = maxGap > 120 ? 60 : maxGap > 60 ? 30 : maxGap > 30 ? 15 : maxGap > 10 ? 5 : 2;
                for (let t = interval; t < maxGap; t += interval) {
                    const pct = 90 - ((t / maxGap) * 75);
                    graphHtml += `
                        <div style="position: absolute; left: ${pct}%; top: 0; bottom: 0; width: 1px; background: var(--border-color); opacity: 0.3;"></div>
                        <div style="position: absolute; left: ${pct}%; bottom: 2px; transform: translateX(-50%); font-size: 8px; color: var(--text-muted); font-family: 'Roboto Mono', monospace;">-${t}s</div>
                    `;
                }
            }
            
            // Render cars in filtered display
            displayRows.forEach((car) => {
                const carNum = car.startnumber || car.col_2 || '?';
                const carClass = car.class || car.col_9 || 'Unknown';
                const pos = car.position || car.col_0 || '?';
                const gap = cumulativeGaps[carNum] || 0;
                const color = classColors[carClass] || '#888';
                
                // Find actual index in full sorted list
                const actualIndex = sortedRows.findIndex(r => (r.startnumber || r.col_2) === carNum);
                
                // Horizontal position: right side is P1 (90%), left side is last (15%)
                const xPct = maxGap > 0 ? 90 - ((gap / maxGap) * 75) : 90 - (actualIndex / sortedRows.length * 75);
                
                // Vertical position: based on class lane
                const yPct = classLanes[carClass] || 50;
                
                // Check states
                const hasUpdate = isRecentlyUpdated(carNum);
                const isTracked = carNum === trackedCarNumber;
                
                // Sizing
                const size = actualIndex === 0 ? 28 : (isTracked ? 26 : 22);
                const fontSize = actualIndex === 0 ? 10 : 9;
                
                // Tooltip
                const gapText = useTimeGaps ? (gap > 0 ? `-${gap.toFixed(1)}s` : 'LEADER') : `P${pos}`;
                const driverName = car.name || car.currentdriver || car.col_4 || '';
                
                // Styles for different states
                let boxShadow = '';
                let borderColor = 'rgba(255,255,255,0.3)';
                let zIndex = 100 - actualIndex;
                let scale = '';
                
                if (isTracked) {
                    boxShadow = '0 0 10px var(--accent-green), 0 0 20px var(--accent-green)';
                    borderColor = 'var(--accent-green)';
                    zIndex = 200;
                    scale = 'scale(1.1)';
                } else if (hasUpdate) {
                    boxShadow = '0 0 8px var(--accent-green)';
                }
                
                graphHtml += `
                    <div onclick="trackCar('${carNum}')" 
                         title="P${pos} #${carNum} ${driverName} | ${carClass} | ${gapText}"
                         style="position: absolute; left: ${xPct}%; top: ${yPct}%; 
                                transform: translate(-50%, -50%) ${scale};
                                width: ${size}px; height: ${size}px; border-radius: 50%; 
                                background: linear-gradient(135deg, ${color} 0%, ${adjustColor(color, -40)} 100%);
                                border: 2px solid ${borderColor};
                                box-shadow: ${boxShadow};
                                display: flex; align-items: center; justify-content: center;
                                cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; 
                                z-index: ${zIndex};"
                         onmouseover="this.style.transform='translate(-50%, -50%) scale(1.3)'; this.style.zIndex='201';"
                         onmouseout="this.style.transform='translate(-50%, -50%) ${scale}'; this.style.zIndex='${zIndex}';">
                        <span style="color: #fff; font-size: ${fontSize}px; font-weight: bold; 
                                     font-family: 'Orbitron', sans-serif; text-shadow: 0 1px 2px rgba(0,0,0,0.6);">
                            ${carNum}
                        </span>
                    </div>
                `;
                
                // Position badge for P1-P3 and tracked car
                if (actualIndex < 3 || isTracked) {
                    const badgeColor = actualIndex === 0 ? '#ffd700' : (actualIndex === 1 ? '#c0c0c0' : (actualIndex === 2 ? '#cd7f32' : 'var(--accent-green)'));
                    graphHtml += `
                        <div style="position: absolute; left: ${xPct}%; top: ${yPct - (laneHeight * 0.35)}%; 
                                    transform: translateX(-50%); 
                                    font-size: 8px; font-weight: 700; color: ${badgeColor}; 
                                    font-family: 'Orbitron', sans-serif;
                                    text-shadow: 0 1px 3px rgba(0,0,0,0.9); z-index: ${zIndex};">
                            P${pos}
                        </div>
                    `;
                }
            });
            
            graphEl.innerHTML = graphHtml;
            
            // Build legend
            let legendHtml = '';
            classOrder.forEach(cls => {
                const color = classColors[cls];
                const count = classCars[cls]?.length || 0;
                legendHtml += `
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 10px; height: 10px; border-radius: 50%; background: ${color}; border: 1px solid rgba(255,255,255,0.2);"></div>
                        <span style="font-size: 11px; color: var(--text-secondary); font-weight: 500;">${cls} <span style="color: var(--text-muted);">(${count})</span></span>
                    </div>
                `;
            });
            
            // Gap info
            if (useTimeGaps) {
                legendHtml += `
                    <div style="padding-left: 12px; border-left: 1px solid var(--border-color);">
                        <span style="font-size: 11px; color: var(--text-muted);">Spread: <strong style="color: var(--accent-cyan);">${maxGap.toFixed(1)}s</strong></span>
                    </div>
                `;
            }
            
            // Filter info
            if (filteredCars) {
                legendHtml += `
                    <div style="padding-left: 12px; border-left: 1px solid var(--border-color);">
                        <span style="font-size: 11px; color: var(--accent-yellow);">Showing ${displayRows.length}/${sortedRows.length}</span>
                    </div>
                `;
            }
            
            // Update indicator legend
            legendHtml += `
                <div style="display: flex; align-items: center; gap: 5px; padding-left: 12px; border-left: 1px solid var(--border-color);">
                    <div style="width: 10px; height: 10px; border-radius: 50%; background: #444; box-shadow: 0 0 5px var(--accent-green);"></div>
                    <span style="font-size: 11px; color: var(--text-muted);">Updated</span>
                </div>
            `;
            
            if (legendEl) legendEl.innerHTML = legendHtml;
        }
        
        // Helper to darken/lighten a hex color
        function adjustColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        // Calculate track position (0-1) using multiple methods
        function getTrackPosition(car, sortedRows, cumulativeGaps, maxGap) {
            const carNum = car.startnumber || car.col_2 || '?';
            const state = car.state || car.col_6 || '';
            
            // Check if car is in pits
            if (state && (state.toLowerCase().includes('pit') || state === 'P' || state === 'IN')) {
                return { position: null, inPit: true, sector: null };
            }
            
            // Method 1: Use marker/sectionmarker field if available
            const marker = car.marker || car.sectionmarker || '';
            if (marker) {
                const markerNum = parseInt(marker);
                if (!isNaN(markerNum) && markerNum >= 1 && markerNum <= 12) {
                    // Marker is typically 1-12 around the track
                    const position = (markerNum - 1) / 12;
                    const sector = Math.ceil(markerNum / 4); // 1-4 = S1, 5-8 = S2, 9-12 = S3
                    return { position, inPit: false, sector };
                }
            }
            
            // Method 2: Use gap-based positioning if we have cumulative gaps
            // Cars closer to leader are further "ahead" on track (higher position = closer to S/F line)
            if (cumulativeGaps && maxGap > 0) {
                const gap = cumulativeGaps[carNum] || 0;
                // Normalize: leader (gap=0) is at position 0.95, last car is at ~0.05
                // This spreads the field around the track based on time gaps
                const position = 0.95 - (gap / maxGap) * 0.9;
                return { position: Math.max(0.05, Math.min(0.95, position)), inPit: false, sector: null };
            }
            
            // Method 3: Use position-based distribution as fallback
            const pos = parseInt(car.position || car.col_0 || '999');
            if (pos > 0 && pos < 900 && sortedRows) {
                const totalCars = sortedRows.length || 1;
                // P1 at 0.95, P_last at 0.05
                const position = 0.95 - ((pos - 1) / totalCars) * 0.9;
                return { position: Math.max(0.05, Math.min(0.95, position)), inPit: false, sector: null };
            }
            
            return { position: null, inPit: false, sector: null };
        }
        
        // Get sector (1, 2, or 3) from track position
        function getSectorFromPosition(position) {
            if (position === null) return null;
            if (position < 0.333) return 1;
            if (position < 0.666) return 2;
            return 3;
        }
        
        // Render the circular track graph with 3 sectors
        function renderCircularGraph(sortedRows) {
            const graphEl = document.getElementById('positionGraphCircular');
            const legendEl = document.getElementById('positionGraphLegend');
            
            if (!graphEl || sortedRows.length === 0) return;
            
            // Get filter
            const filteredCars = getGraphFilteredCars();
            
            // Calculate cumulative gaps from leader (same as linear graph)
            let cumulativeGaps = {};
            let maxGap = 0;
            
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                if (index === 0) {
                    cumulativeGaps[carNum] = 0;
                } else {
                    const gapStr = car.diff || car.col_12 || '0';
                    let gapSeconds = parseGapToSeconds(gapStr);
                    if (gapSeconds === null) gapSeconds = 5; // Default 5 second gap if unknown
                    
                    const prevCar = sortedRows[index - 1];
                    const prevCarNum = prevCar.startnumber || prevCar.col_2 || '?';
                    const prevGap = cumulativeGaps[prevCarNum] || 0;
                    cumulativeGaps[carNum] = prevGap + gapSeconds;
                    maxGap = Math.max(maxGap, cumulativeGaps[carNum]);
                }
            });
            
            // Class colors
            const classColors = {
                'LMP2': '#0088ff',
                'LMP3': '#9c27b0',
                'LMP2 AM': '#ff9800',
                'HYPERCAR': '#ff2222',
                'GT': '#00cc66',
                'GT3': '#00cc66',
                'GT4': '#8bc34a'
            };
            const defaultColors = ['#00bcd4', '#673ab7', '#3f51b5', '#009688', '#4caf50', '#cddc39', '#ff5722', '#795548'];
            let colorIndex = 0;
            
            // Container dimensions
            const width = graphEl.offsetWidth || 600;
            const height = 300;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(centerX, centerY) - 45;
            
            // Build SVG
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${width} ${height}" style="font-family: 'Orbitron', sans-serif;">`;
            
            // Track background
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius + 12}" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="28"/>`;
            
            // Sector arcs with colors
            const sectorColors = ['rgba(255,80,80,0.2)', 'rgba(80,255,80,0.2)', 'rgba(80,80,255,0.2)'];
            for (let i = 0; i < 3; i++) {
                const startAngle = -90 + i * 120;
                const endAngle = startAngle + 120;
                const startRad = startAngle * Math.PI / 180;
                const endRad = endAngle * Math.PI / 180;
                
                const x1 = centerX + radius * Math.cos(startRad);
                const y1 = centerY + radius * Math.sin(startRad);
                const x2 = centerX + radius * Math.cos(endRad);
                const y2 = centerY + radius * Math.sin(endRad);
                
                svg += `<path d="M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 0 1 ${x2} ${y2} Z" fill="${sectorColors[i]}"/>`;
            }
            
            // Main track ring
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="none" stroke="rgba(255,255,255,0.4)" stroke-width="22"/>`;
            svg += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="none" stroke="rgba(0,255,136,0.1)" stroke-width="18"/>`;
            
            // Sector divider lines and labels
            for (let i = 0; i < 3; i++) {
                const angle = (-90 + i * 120) * Math.PI / 180;
                const x1 = centerX + (radius - 18) * Math.cos(angle);
                const y1 = centerY + (radius - 18) * Math.sin(angle);
                const x2 = centerX + (radius + 18) * Math.cos(angle);
                const y2 = centerY + (radius + 18) * Math.sin(angle);
                svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(255,255,255,0.6)" stroke-width="2"/>`;
                
                // Sector label
                const labelAngle = (-30 + i * 120) * Math.PI / 180;
                const labelX = centerX + (radius + 32) * Math.cos(labelAngle);
                const labelY = centerY + (radius + 32) * Math.sin(labelAngle);
                svg += `<text x="${labelX}" y="${labelY}" fill="rgba(255,255,255,0.7)" font-size="12" font-weight="bold" text-anchor="middle" dominant-baseline="middle">S${i + 1}</text>`;
            }
            
            // Start/Finish line at top
            svg += `<rect x="${centerX - 10}" y="${centerY - radius - 14}" width="20" height="8" fill="#fff"/>`;
            svg += `<rect x="${centerX - 10}" y="${centerY - radius - 14}" width="5" height="4" fill="#222"/>`;
            svg += `<rect x="${centerX}" y="${centerY - radius - 14}" width="5" height="4" fill="#222"/>`;
            svg += `<rect x="${centerX - 5}" y="${centerY - radius - 10}" width="5" height="4" fill="#222"/>`;
            svg += `<rect x="${centerX + 5}" y="${centerY - radius - 10}" width="5" height="4" fill="#222"/>`;
            svg += `<text x="${centerX}" y="${centerY - radius - 22}" fill="#fff" font-size="9" font-weight="bold" text-anchor="middle">S/F</text>`;
            
            const classesUsed = new Set();
            let carsOnTrack = 0;
            let carsInPit = 0;
            
            // Place cars on track
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                const carClass = car.class || car.col_9 || 'Unknown';
                const pos = car.position || car.col_0 || '?';
                
                // Check if filtered
                if (filteredCars && !filteredCars.includes(carNum)) return;
                
                classesUsed.add(carClass);
                
                // Get track position
                const trackInfo = getTrackPosition(car, sortedRows, cumulativeGaps, maxGap);
                
                // Get color
                let color = classColors[carClass];
                if (!color) {
                    color = defaultColors[colorIndex % defaultColors.length];
                    classColors[carClass] = color;
                    colorIndex++;
                }
                
                // Check updates and tracking
                const hasUpdate = isRecentlyUpdated(carNum);
                const isTracked = carNum === trackedCarNumber;
                
                let x, y, size, strokeColor, strokeWidth, opacity;
                
                if (trackInfo.inPit) {
                    // Car in pit - place in center area
                    carsInPit++;
                    const pitAngle = (carsInPit * 45 - 90) * Math.PI / 180;
                    const pitRadius = radius * 0.3;
                    x = centerX + pitRadius * Math.cos(pitAngle);
                    y = centerY + pitRadius * Math.sin(pitAngle);
                    size = 10;
                    opacity = 0.5;
                    strokeColor = 'rgba(255,200,0,0.8)';
                    strokeWidth = 2;
                } else if (trackInfo.position !== null) {
                    // Car on track
                    carsOnTrack++;
                    // Map position (0-1) to angle: 0 = top (-90¬∞), going clockwise
                    const angle = (-90 + trackInfo.position * 360) * Math.PI / 180;
                    x = centerX + radius * Math.cos(angle);
                    y = centerY + radius * Math.sin(angle);
                    size = isTracked ? 16 : (index < 3 ? 14 : 12);
                    opacity = 1;
                    strokeColor = hasUpdate ? 'var(--accent-green)' : (isTracked ? 'var(--accent-green)' : 'rgba(255,255,255,0.5)');
                    strokeWidth = hasUpdate || isTracked ? 3 : 1.5;
                } else {
                    // Unknown - spread around inner ring
                    const spreadAngle = (-90 + (index / sortedRows.length) * 360) * Math.PI / 180;
                    x = centerX + radius * 0.5 * Math.cos(spreadAngle);
                    y = centerY + radius * 0.5 * Math.sin(spreadAngle);
                    size = 9;
                    opacity = 0.4;
                    strokeColor = 'rgba(255,255,255,0.3)';
                    strokeWidth = 1;
                }
                
                // Determine sector for tooltip
                const sector = trackInfo.sector || getSectorFromPosition(trackInfo.position);
                const sectorText = sector ? `Sector ${sector}` : (trackInfo.inPit ? 'In Pit' : 'Unknown');
                
                // Shadow and glow effects
                const shadow = isTracked ? `<circle cx="${x}" cy="${y}" r="${size + 6}" fill="rgba(0,255,136,0.3)"/>` : '';
                const glowFilter = hasUpdate ? 'filter: drop-shadow(0 0 4px var(--accent-green));' : '';
                
                // Draw car
                svg += `
                    <g onclick="trackCar('${carNum}')" style="cursor: pointer; ${glowFilter}" class="car-dot">
                        ${shadow}
                        <circle cx="${x}" cy="${y}" r="${size + 2}" fill="rgba(0,0,0,0.6)" opacity="${opacity}"/>
                        <circle cx="${x}" cy="${y}" r="${size}" fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}" opacity="${opacity}"/>
                        <text x="${x}" y="${y + 0.5}" fill="#fff" font-size="${isTracked ? 9 : 8}" font-weight="bold" text-anchor="middle" dominant-baseline="middle" opacity="${opacity}">${carNum}</text>
                        <title>P${pos} #${carNum} | ${carClass} | ${sectorText}</title>
                    </g>
                `;
                
                // Position badge for leader and tracked
                if (index === 0 || isTracked) {
                    const badgeColor = index === 0 ? '#ffd700' : 'var(--accent-green)';
                    const badgeAngle = Math.atan2(y - centerY, x - centerX);
                    const badgeX = x + 18 * Math.cos(badgeAngle);
                    const badgeY = y + 18 * Math.sin(badgeAngle);
                    svg += `<text x="${badgeX}" y="${badgeY}" fill="${badgeColor}" font-size="9" font-weight="bold" text-anchor="middle" dominant-baseline="middle" style="text-shadow: 0 1px 3px rgba(0,0,0,0.9);">P${pos}</text>`;
                }
            });
            
            // Center info
            svg += `<text x="${centerX}" y="${centerY - 8}" fill="rgba(255,255,255,0.5)" font-size="11" text-anchor="middle" font-weight="600">PIT</text>`;
            svg += `<text x="${centerX}" y="${centerY + 8}" fill="rgba(255,200,0,0.7)" font-size="14" font-weight="bold" text-anchor="middle">${carsInPit}</text>`;
            
            svg += '</svg>';
            
            // Add styles and render
            graphEl.innerHTML = `
                <style>
                    .car-dot { transition: opacity 0.15s, transform 0.15s; transform-origin: center; }
                    .car-dot:hover { opacity: 1 !important; transform: scale(1.15); }
                </style>
                ${svg}
            `;
            
            // Build legend
            let legendHtml = '';
            classesUsed.forEach(cls => {
                const color = classColors[cls] || '#888';
                legendHtml += `
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 10px; height: 10px; border-radius: 50%; background: ${color}; border: 1px solid rgba(255,255,255,0.2);"></div>
                        <span style="font-size: 11px; color: var(--text-secondary);">${cls}</span>
                    </div>
                `;
            });
            
            legendHtml += `
                <div style="padding-left: 10px; border-left: 1px solid var(--border-color);">
                    <span style="font-size: 11px; color: var(--accent-green);">Track: <strong>${carsOnTrack}</strong></span>
                </div>
            `;
            
            if (carsInPit > 0) {
                legendHtml += `
                    <div style="padding-left: 10px; border-left: 1px solid var(--border-color);">
                        <span style="font-size: 11px; color: var(--accent-yellow);">Pit: <strong>${carsInPit}</strong></span>
                    </div>
                `;
            }
            
            // Filter info
            if (filteredCars) {
                const displayCount = sortedRows.filter(r => filteredCars.includes(r.startnumber || r.col_2)).length;
                legendHtml += `
                    <div style="padding-left: 10px; border-left: 1px solid var(--border-color);">
                        <span style="font-size: 11px; color: var(--accent-cyan);">Showing ${displayCount}/${sortedRows.length}</span>
                    </div>
                `;
            }
            
            // Update indicator
            legendHtml += `
                <div style="display: flex; align-items: center; gap: 5px; padding-left: 10px; border-left: 1px solid var(--border-color);">
                    <div style="width: 10px; height: 10px; border-radius: 50%; background: #444; box-shadow: 0 0 5px var(--accent-green);"></div>
                    <span style="font-size: 11px; color: var(--text-muted);">Updated</span>
                </div>
            `;
            
            legendEl.innerHTML = legendHtml;
        }
        
        function renderPositionGrid(sortedRows) {
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;">';
            
            sortedRows.forEach((car, index) => {
                const carNum = car.startnumber || car.col_2 || '?';
                const pos = car.position || car.col_0 || '?';
                const name = car.name || car.col_4 || '';
                const driver = car.currentdriver || car.col_7 || '';
                const carClass = car.class || car.col_9 || '';
                const gapAhead = car.diff || car.col_12 || '';
                const lastLap = car.lastroundtime || car.col_13 || '';
                const bestLap = car.fastestroundtime || car.col_14 || '';
                
                const gapSeconds = parseGapToSeconds(gapAhead);
                const carAhead = index > 0 ? sortedRows[index - 1] : null;
                const carBehind = index < sortedRows.length - 1 ? sortedRows[index + 1] : null;
                const carAheadNum = carAhead ? (carAhead.startnumber || carAhead.col_2 || '?') : '';
                const carBehindNum = carBehind ? (carBehind.startnumber || carBehind.col_2 || '?') : '';
                const gapBehind = carBehind ? (carBehind.diff || carBehind.col_12 || '') : '';
                const gapBehindSeconds = parseGapToSeconds(gapBehind);
                
                // Trend
                let trendAheadHtml = '';
                let trendBehindHtml = '';
                if (gapHistory[carNum]) {
                    const trendAhead = formatGapTrend(gapSeconds, gapHistory[carNum].ahead || []);
                    if (trendAhead.trend === 'gaining') {
                        trendAheadHtml = `<span style="color: var(--accent-green);">‚ñ≤ -${trendAhead.diff.toFixed(2)}s</span>`;
                    } else if (trendAhead.trend === 'losing') {
                        trendAheadHtml = `<span style="color: var(--accent-red);">‚ñº +${trendAhead.diff.toFixed(2)}s</span>`;
                    }
                }
                if (gapHistory[carBehindNum]) {
                    const trendBehind = formatGapTrend(gapBehindSeconds, gapHistory[carBehindNum].ahead || []);
                    if (trendBehind.trend === 'gaining') {
                        trendBehindHtml = `<span style="color: var(--accent-red);">‚ö† -${trendBehind.diff.toFixed(2)}s</span>`;
                    } else if (trendBehind.trend === 'losing') {
                        trendBehindHtml = `<span style="color: var(--accent-green);">‚úì +${trendBehind.diff.toFixed(2)}s</span>`;
                    }
                }
                
                // Battle status
                let statusIcon = '';
                let borderColor = 'var(--border-color)';
                let bgColor = 'var(--bg-tertiary)';
                
                if (index === 0) {
                    statusIcon = 'üëë';
                    borderColor = 'var(--accent-yellow)';
                    bgColor = 'rgba(255, 221, 0, 0.1)';
                } else if (gapSeconds !== null && gapSeconds < 1) {
                    statusIcon = 'üî•';
                    borderColor = 'var(--accent-red)';
                    bgColor = 'rgba(255, 30, 30, 0.1)';
                } else if (gapSeconds !== null && gapSeconds < 2) {
                    statusIcon = '‚öîÔ∏è';
                    borderColor = 'var(--accent-yellow)';
                    bgColor = 'rgba(255, 221, 0, 0.05)';
                } else if (gapBehindSeconds !== null && gapBehindSeconds < 1) {
                    statusIcon = 'üõ°Ô∏è';
                    borderColor = 'var(--accent-red)';
                    bgColor = 'rgba(255, 30, 30, 0.05)';
                }
                
                // Format lap times
                let lastLapFormatted = lastLap;
                let bestLapFormatted = bestLap;
                const lastLapVal = parseInt(lastLap, 10);
                const bestLapVal = parseInt(bestLap, 10);
                if (!isNaN(lastLapVal) && lastLapVal > 1000000 && lastLapVal < 999999999999) {
                    lastLapFormatted = formatTime(lastLapVal);
                }
                if (!isNaN(bestLapVal) && bestLapVal > 1000000 && bestLapVal < 999999999999) {
                    bestLapFormatted = formatTime(bestLapVal);
                }
                
                // Check for recent updates
                const hasUpdate = isRecentlyUpdated(carNum);
                const updateAge = getUpdateAge(carNum);
                const changes = getCarChanges(carNum);
                
                // Build update indicator - just a badge, no glowing border
                let updateIndicator = '';
                if (hasUpdate) {
                    const ageText = updateAge !== null ? `${updateAge}s ago` : '';
                    updateIndicator = `
                        <div style="position: absolute; top: -8px; right: -8px; background: var(--accent-green); color: #000; font-size: 9px; font-weight: bold; padding: 2px 6px; border-radius: 10px;">
                            ‚óè ${ageText}
                        </div>
                    `;
                }
                
                html += `
                    <div onclick="trackCar('${carNum}', true); closeFullscreenBattles();" style="background: ${bgColor}; padding: 12px; border-radius: 8px; border: 1px solid ${borderColor}; cursor: pointer; transition: all 0.2s; position: relative;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                        ${updateIndicator}
                        <!-- Header -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">${statusIcon}</span>
                                <span style="font-family: 'Orbitron'; font-weight: bold; font-size: 20px; color: ${index === 0 ? 'var(--accent-yellow)' : 'var(--text-primary)'};">P${pos}</span>
                            </div>
                            <span style="background: var(--accent-red); color: #fff; padding: 4px 10px; border-radius: 4px; font-family: 'Orbitron'; font-size: 14px; font-weight: bold;">#${carNum}</span>
                        </div>
                        
                        <!-- Team & Driver -->
                        <div style="margin-bottom: 10px;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${name}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${driver}</div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 2px;">${carClass}</div>
                        </div>
                        
                        <!-- Gap to car ahead -->
                        ${index > 0 ? `
                        <div style="background: var(--bg-primary); padding: 8px; border-radius: 4px; margin-bottom: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-size: 10px; color: var(--text-muted);">‚Üë TO #${carAheadNum}</span>
                                <span style="font-family: 'Roboto Mono'; font-size: 14px; font-weight: bold;">${gapAhead || '-'}</span>
                            </div>
                            <div style="text-align: right; margin-top: 2px;">${trendAheadHtml}</div>
                        </div>
                        ` : `
                        <div style="background: rgba(255, 221, 0, 0.2); padding: 8px; border-radius: 4px; margin-bottom: 6px; text-align: center;">
                            <span style="font-size: 12px; color: var(--accent-yellow); font-weight: bold;">üèÜ RACE LEADER</span>
                        </div>
                        `}
                        
                        <!-- Gap from car behind -->
                        ${carBehind ? `
                        <div style="background: var(--bg-primary); padding: 8px; border-radius: 4px; margin-bottom: 6px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-size: 10px; color: var(--text-muted);">‚Üì FROM #${carBehindNum}</span>
                                <span style="font-family: 'Roboto Mono'; font-size: 14px; font-weight: bold;">${gapBehind || '-'}</span>
                            </div>
                            <div style="text-align: right; margin-top: 2px;">${trendBehindHtml}</div>
                        </div>
                        ` : ''}
                        
                        <!-- Lap times -->
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 9px; color: var(--text-muted);">LAST</div>
                                <div style="font-family: 'Roboto Mono'; font-size: 11px;">${lastLapFormatted || '-'}</div>
                            </div>
                            <div style="flex: 1; text-align: center;">
                                <div style="font-size: 9px; color: var(--text-muted);">BEST</div>
                                <div style="font-family: 'Roboto Mono'; font-size: 11px; color: var(--accent-purple);">${bestLapFormatted || '-'}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        function renderByClass(sortedRows) {
            // Group by class
            const classes = {};
            sortedRows.forEach(car => {
                const carClass = car.class || car.col_9 || 'Unknown';
                if (!classes[carClass]) classes[carClass] = [];
                classes[carClass].push(car);
            });
            
            let html = '';
            
            Object.keys(classes).forEach(className => {
                const cars = classes[className];
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3 style="font-family: 'Orbitron'; font-size: 14px; color: var(--accent-yellow); margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid var(--border-color);">
                            ${className} <span style="color: var(--text-muted); font-size: 11px;">(${cars.length} cars)</span>
                        </h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 10px;">
                `;
                
                cars.forEach((car, index) => {
                    const carNum = car.startnumber || car.col_2 || '?';
                    const pos = car.position || car.col_0 || '?';
                    const pic = car.position_in_class || car.col_10 || index + 1;
                    const name = car.name || car.col_4 || '';
                    const driver = car.currentdriver || car.col_7 || '';
                    const gapAhead = car.diff || car.col_12 || '';
                    const gapSeconds = parseGapToSeconds(gapAhead);
                    
                    let statusIcon = '';
                    let borderColor = 'var(--border-color)';
                    if (index === 0) {
                        statusIcon = 'üëë';
                        borderColor = 'var(--accent-yellow)';
                    } else if (gapSeconds !== null && gapSeconds < 2) {
                        statusIcon = '‚öîÔ∏è';
                        borderColor = 'var(--accent-red)';
                    }
                    
                    // Get car ahead in class
                    const carAheadInClass = index > 0 ? cars[index - 1] : null;
                    const carAheadNum = carAheadInClass ? (carAheadInClass.startnumber || carAheadInClass.col_2 || '?') : '';
                    
                    // Check for recent updates
                    const hasUpdate = isRecentlyUpdated(carNum);
                    const updateDot = hasUpdate ? '<span style="color: var(--accent-green); margin-left: 4px;">‚óè</span>' : '';
                    
                    html += `
                        <div onclick="trackCar('${carNum}', true); closeFullscreenBattles();" style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; border-left: 3px solid ${borderColor}; cursor: pointer" onmouseover="this.style.background='var(--bg-row-hover)'" onmouseout="this.style.background='var(--bg-tertiary)'">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span>${statusIcon}</span>
                                    <span style="font-family: 'Orbitron'; font-size: 12px; color: var(--text-muted);">P${pos}</span>
                                    <span style="font-family: 'Orbitron'; font-weight: bold; color: var(--accent-yellow);">C${pic}</span>
                                    <span style="background: var(--accent-red); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold;">#${carNum}</span>
                                    ${updateDot}
                                </div>
                                ${index > 0 ? `<span style="font-family: 'Roboto Mono'; font-size: 12px;">${gapAhead || '-'}</span>` : '<span style="font-size: 10px; color: var(--accent-yellow);">LEADER</span>'}
                            </div>
                            <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${name}</div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            return html;
        }
        
        function renderBattleGroups(sortedRows) {
            // Find battles (cars within 3 seconds of each other)
            const battles = [];
            let currentBattle = null;
            
            sortedRows.forEach((car, index) => {
                const gapAhead = car.diff || car.col_12 || '';
                const gapSeconds = parseGapToSeconds(gapAhead);
                
                if (index === 0) {
                    currentBattle = { cars: [car], totalGap: 0 };
                } else if (gapSeconds !== null && gapSeconds < 3) {
                    // Continue battle
                    currentBattle.cars.push(car);
                    currentBattle.totalGap += gapSeconds;
                } else {
                    // End current battle if it has multiple cars
                    if (currentBattle && currentBattle.cars.length > 1) {
                        battles.push(currentBattle);
                    }
                    currentBattle = { cars: [car], totalGap: 0 };
                }
            });
            
            // Don't forget the last battle
            if (currentBattle && currentBattle.cars.length > 1) {
                battles.push(currentBattle);
            }
            
            if (battles.length === 0) {
                return '<div style="color: var(--text-muted); text-align: center; padding: 40px;">No active battles (cars within 3 seconds)</div>';
            }
            
            let html = `<div style="font-size: 12px; color: var(--text-muted); margin-bottom: 15px;">${battles.length} active battle${battles.length > 1 ? 's' : ''} detected</div>`;
            
            battles.forEach((battle, battleIndex) => {
                const intensity = battle.totalGap < battle.cars.length ? 'üî• HOT' : '‚öîÔ∏è ACTIVE';
                const firstCar = battle.cars[0];
                const lastCar = battle.cars[battle.cars.length - 1];
                const firstPos = firstCar.position || firstCar.col_0 || '?';
                const lastPos = lastCar.position || lastCar.col_0 || '?';
                
                html += `
                    <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--border-color);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div>
                                <span style="font-size: 14px; font-weight: bold; color: var(--accent-red);">${intensity} BATTLE</span>
                                <span style="color: var(--text-muted); font-size: 12px; margin-left: 10px;">P${firstPos} - P${lastPos}</span>
                            </div>
                            <span style="font-size: 12px; color: var(--text-secondary);">${battle.cars.length} cars ‚Ä¢ ${battle.totalGap.toFixed(2)}s spread</span>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                `;
                
                battle.cars.forEach((car, index) => {
                    const carNum = car.startnumber || car.col_2 || '?';
                    const pos = car.position || car.col_0 || '?';
                    const name = car.name || car.col_4 || '';
                    const gapAhead = car.diff || car.col_12 || '';
                    
                    // Check for recent updates - just a dot, no glow
                    const hasUpdate = isRecentlyUpdated(carNum);
                    const updateDot = hasUpdate ? '<span style="color: var(--accent-green);">‚óè</span>' : '';
                    
                    html += `
                        <div onclick="trackCar('${carNum}', true); closeFullscreenBattles();" style="background: var(--bg-primary); padding: 8px 12px; border-radius: 6px; cursor: pointer; min-width: 150px; flex: 1" onmouseover="this.style.background='var(--bg-row-hover)'" onmouseout="this.style.background='var(--bg-primary)'">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-family: 'Orbitron'; font-size: 11px; color: var(--text-muted);">P${pos}</span>
                                    <span style="background: var(--accent-red); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-left: 6px;">#${carNum}</span>
                                    ${updateDot}
                                </div>
                                ${index > 0 ? `<span style="font-family: 'Roboto Mono'; font-size: 11px; color: var(--accent-yellow);">${gapAhead}</span>` : ''}
                            </div>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${name}</div>
                        </div>
                    `;
                });
                
                html += '</div></div>';
            });
            
            return html;
        }
        
        // Keyboard shortcut to close modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeFullscreenBattles();
                closeTrackFullscreen();
                closeCarAnalysis();
            }
            // Press 'B' to toggle fullscreen battles (when not typing in input)
            if (e.key === 'b' && document.activeElement.tagName !== 'INPUT') {
                if (document.getElementById('battleModal').classList.contains('hidden')) {
                    openFullscreenBattles();
                } else {
                    closeFullscreenBattles();
                }
            }
            // Press 'T' to toggle track fullscreen (when not typing in input)
            if (e.key === 't' && document.activeElement.tagName !== 'INPUT') {
                if (document.getElementById('trackFullscreenModal').classList.contains('hidden')) {
                    openTrackFullscreen();
                } else {
                    closeTrackFullscreen();
                }
            }
            // Press 'A' to open analysis for tracked car (when not typing in input)
            if (e.key === 'a' && document.activeElement.tagName !== 'INPUT') {
                if (document.getElementById('carAnalysisModal').classList.contains('hidden')) {
                    if (trackedCarNumber) {
                        openCarAnalysis(trackedCarNumber);
                    }
                } else {
                    closeCarAnalysis();
                }
            }
        });
        
        // Check for URL in localStorage or show modal
        const savedUrl = localStorage.getItem('livetiming_ws_url');
        if (savedUrl) {
            el.wsUrlInput.value = savedUrl;
        }
        
        // Save URL when connecting
        const originalConnect = connect;
        connect = function(url) {
            localStorage.setItem('livetiming_ws_url', url);
            originalConnect(url);
        };
        
        // Timer to update race time continuously (every second)
        setInterval(function() {
            if (heatState.elapsedTime && heatState.lastUpdateRealTime) {
                // Estimate current elapsed time based on real clock
                const timeSinceLastUpdate = Date.now() - heatState.lastUpdateRealTime;
                const estimatedElapsed = heatState.elapsedTime + (timeSinceLastUpdate * 1000); // Convert ms to microseconds
                
                // Update displayed elapsed time
                el.clockTime.textContent = formatRaceTime(estimatedElapsed);
                
                // Update time to go and ETA
                let timeToGoMicroseconds = null;
                
                if (heatState.timeLength && heatState.timeLength > 0) {
                    timeToGoMicroseconds = heatState.timeLength - estimatedElapsed;
                } else if (heatState.endTime && heatState.currentTime) {
                    timeToGoMicroseconds = heatState.endTime - heatState.currentTime - (timeSinceLastUpdate * 1000);
                } else if (heatState.lapsLength && heatState.leaderLap > 0) {
                    const lapsRemaining = heatState.lapsLength - heatState.leaderLap;
                    if (lapsRemaining > 0) {
                        const avgLapTime = estimatedElapsed / heatState.leaderLap;
                        timeToGoMicroseconds = avgLapTime * lapsRemaining;
                    }
                }
                
                if (timeToGoMicroseconds !== null && timeToGoMicroseconds > 0) {
                    const prefix = (!heatState.timeLength && !heatState.endTime) ? '~' : '';
                    el.timeToGo.textContent = prefix + formatRaceTime(timeToGoMicroseconds);
                    
                    const isUrgent = timeToGoMicroseconds < 600000000 || 
                                    (heatState.lapsLength && (heatState.lapsLength - heatState.leaderLap) <= 5);
                    el.timeToGo.style.color = isUrgent ? 'var(--accent-red)' : 'var(--accent-yellow)';
                    
                    const timeToGoMs = timeToGoMicroseconds / 1000;
                    const etaDate = new Date(Date.now() + timeToGoMs);
                    el.etaTime.textContent = etaDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                }
            }
        }, 1000);
        
        // Debug logging for heat state (called from handleHeatState)
        function debugHeatState(data) {
            if (data && Object.keys(data).length > 5) {
                console.log('[HeatState] Full init data:', JSON.stringify(data, null, 2));
                console.log('[HeatState] Parsed values:');
                console.log('  - name (n):', data.n);
                console.log('  - startTime (s):', data.s, data.s ? new Date(data.s / 1000 + Date.UTC(2000, 0, 1)).toISOString() : '');
                console.log('  - endTime (e):', data.e, data.e ? new Date(data.e / 1000 + Date.UTC(2000, 0, 1)).toISOString() : '');
                console.log('  - timeLength (lt):', data.lt, data.lt ? formatRaceTime(data.lt) : '');
                console.log('  - lapsLength (lr):', data.lr);
                console.log('  - leaderLap (ll):', data.ll);
                console.log('  - lengthMode (lm):', data.lm);
                console.log('  - currentTime (q):', data.q);
                console.log('  - raceTime (r):', data.r, data.r ? formatRaceTime(data.r) : '');
            }
        }
        
        console.log('Live Timing Display Ready - Refactored with Store & RenderQueue');
    </script>
</body>
</html>
